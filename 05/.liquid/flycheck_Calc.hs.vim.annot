13:1-13:5::Calc.eval :: "ExprT.ExprT -> GHC.Integer.Type.Integer"
13:22-13:23::e :: "{v : GHC.Integer.Type.Integer | v == e}"
14:22-14:26::Calc.eval :: "ExprT.ExprT -> GHC.Integer.Type.Integer"
14:27-14:29::e1 :: "{v : ExprT.ExprT | v == e1}"
14:30-14:31::_ :: "x1:GHC.Integer.Type.Integer\n-> x2:GHC.Integer.Type.Integer\n-> {v : GHC.Integer.Type.Integer | v == x1 + x2}"
14:32-14:36::Calc.eval :: "ExprT.ExprT -> GHC.Integer.Type.Integer"
14:37-14:39::e2 :: "{v : ExprT.ExprT | v == e2}"
15:22-15:26::Calc.eval :: "ExprT.ExprT -> GHC.Integer.Type.Integer"
15:27-15:29::e1 :: "{v : ExprT.ExprT | v == e1}"
15:30-15:31::_ :: "x1:GHC.Integer.Type.Integer\n-> x2:GHC.Integer.Type.Integer\n-> {v : GHC.Integer.Type.Integer | x1 > 0 && x2 > 0 => v >= x1 && v >= x2 && x1 > 1 && x2 > 1 => v > x1 && v > x2 && x1 == 0 || x2 == 0 => v == 0}"
15:32-15:36::Calc.eval :: "ExprT.ExprT -> GHC.Integer.Type.Integer"
15:37-15:39::e2 :: "{v : ExprT.ExprT | v == e2}"
19:1-19:8::Calc.evalStr :: "[GHC.Types.Char] -> (Data.Maybe.Maybe GHC.Integer.Type.Integer)"
19:11-19:15::_ :: "(ExprT.ExprT -> GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe ExprT.ExprT)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)"
19:16-19:20::Calc.eval :: "ExprT.ExprT -> GHC.Integer.Type.Integer"
19:21-19:22::_ :: "((Data.Maybe.Maybe ExprT.ExprT)\n -> (Data.Maybe.Maybe GHC.Integer.Type.Integer))\n-> ([GHC.Types.Char] -> (Data.Maybe.Maybe ExprT.ExprT))\n-> [GHC.Types.Char]\n-> exists [(Data.Maybe.Maybe ExprT.ExprT)].(Data.Maybe.Maybe GHC.Integer.Type.Integer)"
19:23-19:31::_ :: "(GHC.Integer.Type.Integer -> ExprT.ExprT)\n-> (ExprT.ExprT -> ExprT.ExprT -> ExprT.ExprT)\n-> (ExprT.ExprT -> ExprT.ExprT -> ExprT.ExprT)\n-> [GHC.Types.Char]\n-> (Data.Maybe.Maybe ExprT.ExprT)"
19:32-19:37::ExprT.Lit :: "GHC.Integer.Type.Integer -> ExprT.ExprT"
19:38-19:43::ExprT.Add :: "ExprT.ExprT -> ExprT.ExprT -> ExprT.ExprT"
19:44-19:49::ExprT.Mul :: "ExprT.ExprT -> ExprT.ExprT -> ExprT.ExprT"
27:10-27:22::Calc.$fExprExprT :: "(Calc.Expr ExprT.ExprT)"
28:3-28:6::$clit :: "GHC.Integer.Type.Integer -> ExprT.ExprT"
28:9-28:14::_ :: "GHC.Integer.Type.Integer -> ExprT.ExprT"
29:3-29:6::$cadd :: "ExprT.ExprT -> ExprT.ExprT -> ExprT.ExprT"
29:9-29:14::_ :: "ExprT.ExprT -> ExprT.ExprT -> ExprT.ExprT"
30:3-30:6::$cmul :: "ExprT.ExprT -> ExprT.ExprT -> ExprT.ExprT"
30:9-30:14::_ :: "ExprT.ExprT -> ExprT.ExprT -> ExprT.ExprT"
33:1-33:6::Calc.reify :: "ExprT.ExprT -> ExprT.ExprT"
33:9-33:11::GHC.Base.id :: "forall a. x1:a -> {VV : a | VV == x1}"
36:10-36:22::Calc.$fExprInteger :: "(Calc.Expr GHC.Integer.Type.Integer)"
37:3-37:6::$clit :: "x1:GHC.Integer.Type.Integer\n-> {v : GHC.Integer.Type.Integer | v == x1}"
37:9-37:11::_ :: "x1:GHC.Integer.Type.Integer\n-> {v : GHC.Integer.Type.Integer | v == x1}"
38:3-38:6::$cadd :: "x1:GHC.Integer.Type.Integer\n-> x2:GHC.Integer.Type.Integer\n-> {v : GHC.Integer.Type.Integer | v == x1 + x2}"
38:9-38:12::_ :: "x1:GHC.Integer.Type.Integer\n-> x2:GHC.Integer.Type.Integer\n-> {v : GHC.Integer.Type.Integer | v == x1 + x2}"
39:3-39:6::$cmul :: "x1:GHC.Integer.Type.Integer\n-> x2:GHC.Integer.Type.Integer\n-> {v : GHC.Integer.Type.Integer | x1 > 0 && x2 > 0 => v >= x1 && v >= x2 && x1 > 1 && x2 > 1 => v > x1 && v > x2 && x1 == 0 || x2 == 0 => v == 0}"
39:9-39:12::_ :: "x1:GHC.Integer.Type.Integer\n-> x2:GHC.Integer.Type.Integer\n-> {v : GHC.Integer.Type.Integer | x1 > 0 && x2 > 0 => v >= x1 && v >= x2 && x1 > 1 && x2 > 1 => v > x1 && v > x2 && x1 == 0 || x2 == 0 => v == 0}"
41:10-41:19::Calc.$fExprBool :: "(Calc.Expr GHC.Types.Bool)"
42:3-42:6::$clit :: "GHC.Integer.Type.Integer -> GHC.Types.Bool"
42:10-42:11::_ :: "x1:GHC.Integer.Type.Integer\n-> x2:GHC.Integer.Type.Integer\n-> {v : GHC.Types.Bool | Prop v <=> x1 > v}"
43:3-43:6::$cadd :: "x1:GHC.Types.Bool\n-> x2:GHC.Types.Bool\n-> {v : GHC.Types.Bool | Prop v <=> Prop x1 || Prop v}"
43:9-43:13::_ :: "x1:GHC.Types.Bool\n-> x2:GHC.Types.Bool\n-> {v : GHC.Types.Bool | Prop v <=> Prop x1 || Prop v}"
44:3-44:6::$cmul :: "x1:GHC.Types.Bool\n-> x2:GHC.Types.Bool\n-> {v : GHC.Types.Bool | Prop v <=> Prop x1 && Prop v}"
44:9-44:13::_ :: "x1:GHC.Types.Bool\n-> x2:GHC.Types.Bool\n-> {v : GHC.Types.Bool | Prop v <=> Prop x1 && Prop v}"
46:39-46:43::Calc.$fShowMinMax :: "forall a.\n(GHC.Show.Show [Contravariant]\n[] a) =>\n(GHC.Show.Show (Calc.MinMax a))"
46:45-46:47::Calc.$fEqMinMax :: "forall a.\n(GHC.Classes.Eq [Contravariant]\n[] a) =>\n(GHC.Classes.Eq (Calc.MinMax a))"
47:39-47:43::Calc.$fShowMod7 :: "forall a.\n(GHC.Show.Show [Contravariant]\n[] a) =>\n(GHC.Show.Show (Calc.Mod7 a))"
47:45-47:47::Calc.$fEqMod7 :: "forall a.\n(GHC.Classes.Eq [Contravariant]\n[] a) =>\n(GHC.Classes.Eq (Calc.Mod7 a))"
49:10-49:22::Calc.$fMonadMinMax :: "(GHC.Base.Monad Calc.MinMax)"
50:3-50:9::$creturn :: "forall a. a -> (Calc.MinMax a)"
50:20-50:26::_ :: "a -> (Calc.MinMax a)"
51:12-51:15::$c>>= :: "forall a b.\n(Calc.MinMax a) -> (a -> (Calc.MinMax b)) -> (Calc.MinMax b)"
51:16-51:17::f :: "a -> (Calc.MinMax b)"
51:20-51:21::_ :: "a -> (Calc.MinMax b)"
51:22-51:23::lq_anf__d3NO :: "a"
53:10-53:20::Calc.$fMonadMod7 :: "(GHC.Base.Monad Calc.Mod7)"
54:3-54:9::$creturn :: "forall a. a -> (Calc.Mod7 a)"
54:18-54:22::_ :: "a -> (Calc.Mod7 a)"
55:10-55:13::$c>>= :: "forall a b. (Calc.Mod7 a) -> (a -> (Calc.Mod7 b)) -> (Calc.Mod7 b)"
55:14-55:15::f :: "a -> (Calc.Mod7 b)"
55:18-55:19::_ :: "a -> (Calc.Mod7 b)"
55:20-55:21::lq_anf__d3NP :: "a"
57:10-57:31::Calc.$fExprMinMax :: "(Calc.Expr (Calc.MinMax GHC.Integer.Type.Integer))"
58:3-58:6::$clit :: "GHC.Integer.Type.Integer -> (Calc.MinMax GHC.Integer.Type.Integer)"
58:9-58:15::Calc.$fMonadMinMax :: "(GHC.Base.Monad Calc.MinMax)"
59:3-59:6::$cadd :: "(Calc.MinMax GHC.Integer.Type.Integer)\n-> (Calc.MinMax GHC.Integer.Type.Integer)\n-> (Calc.MinMax GHC.Integer.Type.Integer)"
59:9-59:15::Calc.$fMonadMinMax :: "(GHC.Base.Monad Calc.MinMax)"
59:16-59:19::lq_anf__d3NQ :: "x1:GHC.Integer.Type.Integer\n-> x2:GHC.Integer.Type.Integer\n-> {v : GHC.Integer.Type.Integer | v == if (x1 > v) then x1 else v}"
60:3-60:6::$cmul :: "(Calc.MinMax GHC.Integer.Type.Integer)\n-> (Calc.MinMax GHC.Integer.Type.Integer)\n-> (Calc.MinMax GHC.Integer.Type.Integer)"
60:9-60:15::Calc.$fMonadMinMax :: "(GHC.Base.Monad Calc.MinMax)"
60:16-60:19::lq_anf__d3NR :: "x1:GHC.Integer.Type.Integer\n-> x2:GHC.Integer.Type.Integer\n-> {v : GHC.Integer.Type.Integer | v == if (x1 < v) then x1 else v}"
62:10-62:29::Calc.$fExprMod7 :: "(Calc.Expr (Calc.Mod7 GHC.Integer.Type.Integer))"
63:3-63:6::$clit :: "GHC.Integer.Type.Integer -> (Calc.Mod7 GHC.Integer.Type.Integer)"
63:13-63:19::lq_anf__d3NS :: "GHC.Integer.Type.Integer -> (Calc.Mod7 GHC.Integer.Type.Integer)"
63:20-63:21::_ :: "(GHC.Integer.Type.Integer -> (Calc.Mod7 GHC.Integer.Type.Integer))\n-> (GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer)\n-> GHC.Integer.Type.Integer\n-> exists [GHC.Integer.Type.Integer].(Calc.Mod7 GHC.Integer.Type.Integer)"
63:23-63:28::_ :: "x1:GHC.Integer.Type.Integer\n-> x2:{v : GHC.Integer.Type.Integer | v /= 0}\n-> {v : GHC.Integer.Type.Integer | 0 <= x1 && 0 < x2 => 0 <= v && v < x2 && v == x1 mod x2}"
64:3-64:6::$cadd :: "(Calc.Mod7 GHC.Integer.Type.Integer)\n-> (Calc.Mod7 GHC.Integer.Type.Integer)\n-> (Calc.Mod7 GHC.Integer.Type.Integer)"
64:7-64:8::a :: "(Calc.Mod7 GHC.Integer.Type.Integer)"
64:9-64:10::b :: "(Calc.Mod7 GHC.Integer.Type.Integer)"
64:13-64:19::Calc.$fMonadMod7 :: "(GHC.Base.Monad Calc.Mod7)"
64:20-64:23::lq_anf__d3OJ :: "x1:GHC.Integer.Type.Integer\n-> x2:GHC.Integer.Type.Integer\n-> {v : GHC.Integer.Type.Integer | v == x1 + v}"
64:24-64:25::a :: "{v : (Calc.Mod7 GHC.Integer.Type.Integer) | v == a}"
64:26-64:27::b :: "{v : (Calc.Mod7 GHC.Integer.Type.Integer) | v == b}"
64:28-64:31::Calc.$fMonadMod7 :: "(GHC.Base.Monad Calc.Mod7)"
64:32-64:35::lq_anf__d3OL :: "GHC.Integer.Type.Integer -> (Calc.Mod7 GHC.Integer.Type.Integer)"
65:3-65:6::$cmul :: "(Calc.Mod7 GHC.Integer.Type.Integer)\n-> (Calc.Mod7 GHC.Integer.Type.Integer)\n-> (Calc.Mod7 GHC.Integer.Type.Integer)"
65:7-65:8::a :: "(Calc.Mod7 GHC.Integer.Type.Integer)"
65:9-65:10::b :: "(Calc.Mod7 GHC.Integer.Type.Integer)"
65:13-65:19::Calc.$fMonadMod7 :: "(GHC.Base.Monad Calc.Mod7)"
65:20-65:23::lq_anf__d3OM :: "x1:GHC.Integer.Type.Integer\n-> x2:GHC.Integer.Type.Integer\n-> {v : GHC.Integer.Type.Integer | x1 > 0 && x2 > 0 => v >= x1 && v >= x2 && x1 > 1 && x2 > 1 => v > x1 && v > x2 && x1 == 0 || x2 == 0 => v == 0}"
65:24-65:25::a :: "{v : (Calc.Mod7 GHC.Integer.Type.Integer) | v == a}"
65:26-65:27::b :: "{v : (Calc.Mod7 GHC.Integer.Type.Integer) | v == b}"
65:28-65:31::Calc.$fMonadMod7 :: "(GHC.Base.Monad Calc.Mod7)"
65:32-65:35::lq_anf__d3OO :: "GHC.Integer.Type.Integer -> (Calc.Mod7 GHC.Integer.Type.Integer)"
68:1-68:8::Calc.testExp :: "forall a. (Calc.Expr [Bivariant]\n[] a) => (Data.Maybe.Maybe a)"
68:11-68:19::_ :: "(GHC.Integer.Type.Integer -> a)\n-> (a -> a -> a)\n-> (a -> a -> a)\n-> [GHC.Types.Char]\n-> (Data.Maybe.Maybe a)"
68:20-68:23::lq_anf__d3NK :: "GHC.Integer.Type.Integer -> a"
68:24-68:27::lq_anf__d3NL :: "a -> a -> a"
68:28-68:31::lq_anf__d3NM :: "a -> a -> a"
68:32-68:46::lq_anf__d3NN :: "{v : [GHC.Types.Char] | len v >= 0}"
70:1-70:12::Calc.testInteger :: "(Data.Maybe.Maybe GHC.Integer.Type.Integer)"
70:15-70:22::Calc.$fExprInteger :: "{v : (Calc.Expr GHC.Integer.Type.Integer) | v == Calc.$fExprInteger}"
71:1-71:9::Calc.testBool :: "(Data.Maybe.Maybe GHC.Types.Bool)"
71:15-71:22::Calc.$fExprBool :: "{v : (Calc.Expr GHC.Types.Bool) | v == Calc.$fExprBool}"
72:1-72:7::Calc.testMM :: "(Data.Maybe.Maybe (Calc.MinMax GHC.Integer.Type.Integer))"
72:15-72:22::Calc.$fExprMinMax :: "{v : (Calc.Expr (Calc.MinMax GHC.Integer.Type.Integer)) | v == Calc.$fExprMinMax}"
73:1-73:8::Calc.testSat :: "(Data.Maybe.Maybe (Calc.Mod7 GHC.Integer.Type.Integer))"
73:15-73:22::Calc.$fExprMod7 :: "(Calc.Expr (Calc.Mod7 GHC.Integer.Type.Integer))"
76:10-76:24::Calc.$fExpr[] :: "(Calc.Expr [StackVM.StackExp])"
77:3-77:6::$clit :: "GHC.Integer.Type.Integer -> [StackVM.StackExp]"
77:14-77:15::_ :: "x1:StackVM.StackExp\n-> x2:[StackVM.StackExp]\n-> {v : [StackVM.StackExp] | null v <=> false && xListSelector v == x1 && len v == 1 + len x2 && xsListSelector v == x2}"
77:15-77:17::_ :: "{v : [StackVM.StackExp] | null v <=> true && len v == 0}"
77:19-77:20::_ :: "(StackVM.StackExp -> [StackVM.StackExp])\n-> (GHC.Integer.Type.Integer -> StackVM.StackExp)\n-> GHC.Integer.Type.Integer\n-> exists [StackVM.StackExp].[StackVM.StackExp]"
77:21-77:28::StackVM.PushI :: "GHC.Integer.Type.Integer -> StackVM.StackExp"
78:3-78:6::$cadd :: "[StackVM.StackExp] -> [StackVM.StackExp] -> [StackVM.StackExp]"
78:7-78:8::x :: "[StackVM.StackExp]"
78:9-78:10::y :: "[StackVM.StackExp]"
78:13-78:14::x :: "{v : [StackVM.StackExp] | v == x && len v >= 0}"
78:15-78:17::_ :: "x1:[StackVM.StackExp]\n-> x2:[StackVM.StackExp]\n-> {v : [StackVM.StackExp] | len v == len x1 + len v}"
78:18-78:19::y :: "{v : [StackVM.StackExp] | v == y && len v >= 0}"
78:20-78:22::_ :: "x1:[StackVM.StackExp]\n-> x2:[StackVM.StackExp]\n-> {v : [StackVM.StackExp] | len v == len x1 + len v}"
78:23-78:30::lq_anf__d3NY :: "{v : [StackVM.StackExp] | null v <=> false && xListSelector v == StackVM.Add && len v >= 0}"
78:24-78:29::StackVM.Add :: "{v : StackVM.StackExp | v == StackVM.Add}"
79:3-79:6::$cmul :: "[StackVM.StackExp] -> [StackVM.StackExp] -> [StackVM.StackExp]"
79:7-79:8::x :: "[StackVM.StackExp]"
79:9-79:10::y :: "[StackVM.StackExp]"
79:13-79:14::x :: "{v : [StackVM.StackExp] | v == x && len v >= 0}"
79:15-79:17::_ :: "x1:[StackVM.StackExp]\n-> x2:[StackVM.StackExp]\n-> {v : [StackVM.StackExp] | len v == len x1 + len v}"
79:18-79:19::y :: "{v : [StackVM.StackExp] | v == y && len v >= 0}"
79:20-79:22::_ :: "x1:[StackVM.StackExp]\n-> x2:[StackVM.StackExp]\n-> {v : [StackVM.StackExp] | len v == len x1 + len v}"
79:23-79:30::lq_anf__d3NV :: "{v : [StackVM.StackExp] | null v <=> false && xListSelector v == StackVM.Mul && len v >= 0}"
79:24-79:29::StackVM.Mul :: "{v : StackVM.StackExp | v == StackVM.Mul}"
82:1-82:8::Calc.compile :: "[GHC.Types.Char] -> (Data.Maybe.Maybe [StackVM.StackExp])"
82:11-82:19::_ :: "(GHC.Integer.Type.Integer -> [StackVM.StackExp])\n-> ([StackVM.StackExp] -> [StackVM.StackExp] -> [StackVM.StackExp])\n-> ([StackVM.StackExp] -> [StackVM.StackExp] -> [StackVM.StackExp])\n-> [GHC.Types.Char]\n-> (Data.Maybe.Maybe [StackVM.StackExp])"
82:20-82:23::lq_anf__d3OW :: "GHC.Integer.Type.Integer -> [StackVM.StackExp]"
82:24-82:27::lq_anf__d3OX :: "[StackVM.StackExp] -> [StackVM.StackExp] -> [StackVM.StackExp]"
82:28-82:31::lq_anf__d3OY :: "[StackVM.StackExp] -> [StackVM.StackExp] -> [StackVM.StackExp]"
88:10-88:25::Calc.$fExprVarExprT :: "(Calc.Expr VarExprT.VarExprT)"
89:3-89:6::$clit :: "GHC.Integer.Type.Integer -> VarExprT.VarExprT"
89:9-89:14::_ :: "GHC.Integer.Type.Integer -> VarExprT.VarExprT"
90:3-90:6::$cadd :: "VarExprT.VarExprT -> VarExprT.VarExprT -> VarExprT.VarExprT"
90:9-90:14::_ :: "VarExprT.VarExprT -> VarExprT.VarExprT -> VarExprT.VarExprT"
91:3-91:6::$cmul :: "VarExprT.VarExprT -> VarExprT.VarExprT -> VarExprT.VarExprT"
91:9-91:14::_ :: "VarExprT.VarExprT -> VarExprT.VarExprT -> VarExprT.VarExprT"
93:10-93:28::Calc.$fHasVarsVarExprT :: "(Calc.HasVars VarExprT.VarExprT)"
94:3-94:6::$cvar :: "[GHC.Types.Char] -> VarExprT.VarExprT"
94:9-94:14::_ :: "[GHC.Types.Char] -> VarExprT.VarExprT"
98:10-98:40::Calc.$fHasVars(->) :: "(Calc.HasVars (Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n              -> (Data.Maybe.Maybe GHC.Integer.Type.Integer))"
99:3-99:6::$cvar :: "[GHC.Types.Char]\n-> (Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)"
99:9-99:17::_ :: "[GHC.Types.Char]\n-> (Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)"
101:10-101:37::Calc.$fExpr(->) :: "(Calc.Expr (Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n           -> (Data.Maybe.Maybe GHC.Integer.Type.Integer))"
102:3-102:6::$clit :: "x:GHC.Integer.Type.Integer\n-> (Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n-> {v : (Data.Maybe.Maybe GHC.Integer.Type.Integer) | isJust v <=> true && fromJust v == x}"
102:7-102:8::x :: "GHC.Integer.Type.Integer"
102:11-102:12::e :: "(Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)"
102:15-102:19::_ :: "x1:GHC.Integer.Type.Integer\n-> {v : (Data.Maybe.Maybe GHC.Integer.Type.Integer) | isJust v <=> true && fromJust v == x1}"
102:20-102:21::x :: "{v : GHC.Integer.Type.Integer | v == x}"
103:3-103:6::$cadd :: "((Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n -> (Data.Maybe.Maybe GHC.Integer.Type.Integer))\n-> ((Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n    -> (Data.Maybe.Maybe GHC.Integer.Type.Integer))\n-> (Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)"
103:7-103:8::a :: "(Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)"
103:9-103:10::b :: "(Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)"
103:11-103:12::e :: "(Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)"
103:15-103:21::_ :: "(GHC.Integer.Type.Integer\n -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)"
103:22-103:25::lq_anf__d3OD :: "x1:GHC.Integer.Type.Integer\n-> x2:GHC.Integer.Type.Integer\n-> {v : GHC.Integer.Type.Integer | v == x1 + v}"
103:27-103:28::_ :: "(Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)"
103:29-103:30::e :: "{v : (Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer) | v == e}"
103:33-103:34::_ :: "(Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)"
103:35-103:36::e :: "{v : (Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer) | v == e}"
104:3-104:6::$cmul :: "((Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n -> (Data.Maybe.Maybe GHC.Integer.Type.Integer))\n-> ((Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n    -> (Data.Maybe.Maybe GHC.Integer.Type.Integer))\n-> (Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)"
104:7-104:8::a :: "(Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)"
104:9-104:10::b :: "(Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)"
104:11-104:12::e :: "(Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)"
104:15-104:21::_ :: "(GHC.Integer.Type.Integer\n -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)"
104:22-104:25::lq_anf__d3OG :: "x1:GHC.Integer.Type.Integer\n-> x2:GHC.Integer.Type.Integer\n-> {v : GHC.Integer.Type.Integer | x1 > 0 && x2 > 0 => v >= x1 && v >= x2 && x1 > 1 && x2 > 1 => v > x1 && v > x2 && x1 == 0 || x2 == 0 => v == 0}"
104:27-104:28::_ :: "(Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)"
104:29-104:30::e :: "{v : (Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer) | v == e}"
104:33-104:34::_ :: "(Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)"
104:35-104:36::e :: "{v : (Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer) | v == e}"
107:1-107:9::Calc.withVars :: "[([GHC.Types.Char], GHC.Integer.Type.Integer)]\n-> ((Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n    -> (Data.Maybe.Maybe GHC.Integer.Type.Integer))\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)"
107:10-107:12::vs :: "[([GHC.Types.Char], GHC.Integer.Type.Integer)]"
107:13-107:16::exp :: "(Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)"
107:19-107:22::exp :: "(Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)"
107:23-107:24::_ :: "((Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n -> (Data.Maybe.Maybe GHC.Integer.Type.Integer))\n-> (Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)\n-> (Data.Maybe.Maybe GHC.Integer.Type.Integer)"
107:25-107:35::_ :: "[([GHC.Types.Char], GHC.Integer.Type.Integer)]\n-> (Data.Map.Base.Map [GHC.Types.Char] GHC.Integer.Type.Integer)"
107:36-107:38::vs :: "{v : [([GHC.Types.Char], GHC.Integer.Type.Integer)] | v == vs && len v >= 0}"