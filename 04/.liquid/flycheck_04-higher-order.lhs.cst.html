<!--
{-# OPTIONS_GHC -Wall #-}
-->

<h1 id="higher-order-programming-and-type-inference">Higher-order programming and type inference</h1>
<p>CIS 194 Week 4<br />4 February 2013</p>
<p>Suggested reading:</p>
<ul>
<li><em>Learn You a Haskell for Great Good</em> chapter &quot;Higher-Order Functions&quot; (Chapter 5 in the printed book; <a href="http://learnyouahaskell.com/higher-order-functions">Chapter 6 online</a>)</li>
</ul>
<h2 id="anonymous-functions">Anonymous functions</h2>
<p>Suppose we want to write a function</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">greaterThan100 ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]</code></pre>
<p>which keeps only those <code>Integers</code> from the input list which are greater than 100. For example,</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">greaterThan100 [<span class="dv">1</span>,<span class="dv">9</span>,<span class="dv">349</span>,<span class="dv">6</span>,<span class="dv">907</span>,<span class="dv">98</span>,<span class="dv">105</span>] <span class="fu">=</span> [<span class="dv">349</span>,<span class="dv">907</span>,<span class="dv">105</span>]<span class="fu">.</span></code></pre>
<p>By now, we know a nice way to do this:</p>
<pre><span class=hs-linenum>33: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>gt100</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Integer</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum>34: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp_x945:GHC.Integer.Type.Integer^"lq_tmp_x199"
-&gt; GHC.Types.Bool^"lq_tmp_x200"</span><span class='hs-definition'>gt100</span></a> <a class=annot href="#"><span class=annottext>GHC.Integer.Type.Integer^"lq_tmp_x199"</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x963 : GHC.Integer.Type.Integer^"lq_tmp_x199" | lq_tmp_x963 == x#a1b3}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x955:{lq_tmp_x960 : GHC.Integer.Type.Integer^"lq_tmp_x959" | k_958[VV#957:=lq_tmp_x960][lq_tmp_x954:=fix#GHC.Integer.Type.#36#fOrdInteger#35#rhv]}
-&gt; lq_tmp_x956:{lq_tmp_x960 : GHC.Integer.Type.Integer^"lq_tmp_x959" | k_958[VV#957:=lq_tmp_x960][lq_tmp_x954:=fix#GHC.Integer.Type.#36#fOrdInteger#35#rhv]}
-&gt; {lq_tmp_x950 : GHC.Types.Bool | Prop lq_tmp_x950 &lt;=&gt; lq_tmp_x955 &gt; lq_tmp_x956}</span><span class='hs-varop'>&gt;</span></a> <span class='hs-num'>100</span>
<span class=hs-linenum>35: </span><span class='hs-varop'>&gt;</span>
<span class=hs-linenum>36: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>greaterThan100</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Integer</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Integer</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>37: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp_x966:[GHC.Integer.Type.Integer^"lq_tmp_x202"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x204"
-&gt; [GHC.Integer.Type.Integer^"lq_tmp_x205"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x207"</span><span class='hs-definition'>greaterThan100</span></a> <a class=annot href="#"><span class=annottext>[GHC.Integer.Type.Integer^"lq_tmp_x202"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x204"</span><span class='hs-varid'>xs</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x977:(lq_tmp_x976:{lq_tmp_x982 : GHC.Integer.Type.Integer^"lq_tmp_x981" | k_980[VV#979:=lq_tmp_x982]}
             -&gt; GHC.Types.Bool)
-&gt; lq_tmp_x978:[{lq_tmp_x982 : GHC.Integer.Type.Integer^"lq_tmp_x981" | k_980[VV#979:=lq_tmp_x982]}]
-&gt; {lq_tmp_x973 : [{lq_tmp_x982 : GHC.Integer.Type.Integer^"lq_tmp_x981" | k_980[VV#979:=lq_tmp_x982]}] | len lq_tmp_x973 &lt;= len lq_tmp_x978}</span><span class='hs-varid'>filter</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x986:GHC.Integer.Type.Integer^"lq_tmp_x199"
-&gt; GHC.Types.Bool^"lq_tmp_x200"</span><span class='hs-varid'>gt100</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x990 : [GHC.Integer.Type.Integer^"lq_tmp_x202"]&lt;\lq_tmp_x988 VV -&gt; True&gt;^"lq_tmp_x204" | len lq_tmp_x990 &gt;= 0 &amp;&amp; lq_tmp_x990 == xs#a1b4}</span><span class='hs-varid'>xs</span></a>
</pre>
<p>But it's annoying to give <code>gt100</code> a name, since we are probably never going to use it again. Instead, we can use an <em>anonymous function</em>, also known as a <em>lambda abstraction</em>:</p>
<pre><span class=hs-linenum>43: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>greaterThan100_2</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Integer</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Integer</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>44: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp_x893:[GHC.Integer.Type.Integer^"lq_tmp_x192"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x194"
-&gt; [GHC.Integer.Type.Integer^"lq_tmp_x195"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x197"</span><span class='hs-definition'>greaterThan100_2</span></a> <a class=annot href="#"><span class=annottext>[GHC.Integer.Type.Integer^"lq_tmp_x192"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x194"</span><span class='hs-varid'>xs</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x930:(lq_tmp_x929:{lq_tmp_x935 : GHC.Integer.Type.Integer^"lq_tmp_x934" | k_933[VV#932:=lq_tmp_x935]}
             -&gt; GHC.Types.Bool)
-&gt; lq_tmp_x931:[{lq_tmp_x935 : GHC.Integer.Type.Integer^"lq_tmp_x934" | k_933[VV#932:=lq_tmp_x935]}]
-&gt; {lq_tmp_x926 : [{lq_tmp_x935 : GHC.Integer.Type.Integer^"lq_tmp_x934" | k_933[VV#932:=lq_tmp_x935]}] | len lq_tmp_x926 &lt;= len lq_tmp_x931}</span><span class='hs-varid'>filter</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>lq_tmp_x939:{lq_tmp_x936 : GHC.Integer.Type.Integer^"lq_tmp_x897" | k_896[VV#895:=lq_tmp_x936]}
-&gt; {lq_tmp_x937 : GHC.Types.Bool^"lq_tmp_x901" | k_900[VV#899:=lq_tmp_x937][x#a1b6:=lq_tmp_x939]}</span><span class='hs-keyglyph'>\</span></a><a class=annot href="#"><span class=annottext>{VV#895 : GHC.Integer.Type.Integer^"lq_tmp_x897" | k_896}</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x918 : GHC.Integer.Type.Integer^"lq_tmp_x897" | k_896[VV#895:=lq_tmp_x918] &amp;&amp; lq_tmp_x918 == x#a1b6}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x910:{lq_tmp_x915 : GHC.Integer.Type.Integer^"lq_tmp_x914" | k_913[VV#912:=lq_tmp_x915][lq_tmp_x909:=fix#GHC.Integer.Type.#36#fOrdInteger#35#rhv]}
-&gt; lq_tmp_x911:{lq_tmp_x915 : GHC.Integer.Type.Integer^"lq_tmp_x914" | k_913[VV#912:=lq_tmp_x915][lq_tmp_x909:=fix#GHC.Integer.Type.#36#fOrdInteger#35#rhv]}
-&gt; {lq_tmp_x905 : GHC.Types.Bool | Prop lq_tmp_x905 &lt;=&gt; lq_tmp_x910 &gt; lq_tmp_x911}</span><span class='hs-varop'>&gt;</span></a> <span class='hs-num'>100</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x943 : [GHC.Integer.Type.Integer^"lq_tmp_x192"]&lt;\lq_tmp_x941 VV -&gt; True&gt;^"lq_tmp_x194" | len lq_tmp_x943 &gt;= 0 &amp;&amp; lq_tmp_x943 == xs#a1b5}</span><span class='hs-varid'>xs</span></a>
</pre>
<p><code>\x -&gt; x &gt; 100</code> (the backslash is supposed to look kind of like a lambda with the short leg missing) is the function which takes a single argument <code>x</code> and outputs whether <code>x</code> is greater than 100.</p>
<p>Lambda abstractions can also have multiple arguments. For example:</p>
<pre><code>Prelude&gt; (\x y z -&gt; [x,2*y,3*z]) 5 6 3
[5,12,9]</code></pre>
<p>However, in the particular case of <code>greaterThan100</code>, there's an even better way to write it, without a lambda abstraction:</p>
<pre><span class=hs-linenum>58: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>greaterThan100_3</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Integer</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Integer</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>59: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp_x844:[GHC.Integer.Type.Integer^"lq_tmp_x185"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x187"
-&gt; [GHC.Integer.Type.Integer^"lq_tmp_x188"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x190"</span><span class='hs-definition'>greaterThan100_3</span></a> <a class=annot href="#"><span class=annottext>[GHC.Integer.Type.Integer^"lq_tmp_x185"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x187"</span><span class='hs-varid'>xs</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x878:(lq_tmp_x877:{lq_tmp_x883 : GHC.Integer.Type.Integer^"lq_tmp_x882" | k_881[VV#880:=lq_tmp_x883]}
             -&gt; GHC.Types.Bool)
-&gt; lq_tmp_x879:[{lq_tmp_x883 : GHC.Integer.Type.Integer^"lq_tmp_x882" | k_881[VV#880:=lq_tmp_x883]}]
-&gt; {lq_tmp_x874 : [{lq_tmp_x883 : GHC.Integer.Type.Integer^"lq_tmp_x882" | k_881[VV#880:=lq_tmp_x883]}] | len lq_tmp_x874 &lt;= len lq_tmp_x879}</span><span class='hs-varid'>filter</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>lq_tmp_x858:{lq_tmp_x863 : GHC.Integer.Type.Integer^"lq_tmp_x862" | k_861[VV#860:=lq_tmp_x863][lq_tmp_x857:=fix#GHC.Integer.Type.#36#fOrdInteger#35#rhv]}
-&gt; lq_tmp_x859:{lq_tmp_x863 : GHC.Integer.Type.Integer^"lq_tmp_x862" | k_861[VV#860:=lq_tmp_x863][lq_tmp_x857:=fix#GHC.Integer.Type.#36#fOrdInteger#35#rhv]}
-&gt; {lq_tmp_x853 : GHC.Types.Bool | Prop lq_tmp_x853 &lt;=&gt; lq_tmp_x858 &gt; lq_tmp_x859}</span><span class='hs-varop'>&gt;</span></a><span class='hs-num'>100</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x891 : [GHC.Integer.Type.Integer^"lq_tmp_x185"]&lt;\lq_tmp_x889 VV -&gt; True&gt;^"lq_tmp_x187" | len lq_tmp_x891 &gt;= 0 &amp;&amp; lq_tmp_x891 == xs#a1b7}</span><span class='hs-varid'>xs</span></a>
</pre>
<p><code>(&gt;100)</code> is an <em>operator section</em>: if <code>?</code> is an operator, then <code>(?y)</code> is equivalent to the function <code>\x -&gt; x ? y</code>, and <code>(y?)</code> is equivalent to <code>\x -&gt; y ? x</code>. In other words, using an operator section allows us to <em>partially apply</em> an operator to one of its two arguments. What we get is a function of a single argument. Here are some examples:</p>
<pre><code>Prelude&gt; (&gt;100) 102
True
Prelude&gt; (100&gt;) 102
False
Prelude&gt; map (*6) [1..5]
[6,12,18,24,30]</code></pre>
<h2 id="function-composition">Function composition</h2>
<p>Before reading on, can you write down a function whose type is</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c)</code></pre>
<p>?</p>
<p>Let's try. It has to take two arguments, both of which are functions, and output a function.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foo f g <span class="fu">=</span> <span class="fu">...</span></code></pre>
<p>In the place of the <code>...</code> we need to write a function of type <code>a -&gt; c</code>. Well, we can create a function using a lambda abstraction:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foo f g <span class="fu">=</span> \x <span class="ot">-&gt;</span> <span class="fu">...</span></code></pre>
<p><code>x</code> will have type <code>a</code>, and now in the <code>...</code> we need to write an expression of type <code>c</code>. Well, we have a function <code>g</code> which can turn an <code>a</code> into a <code>b</code>, and a function <code>f</code> which can turn a <code>b</code> into a <code>c</code>, so this ought to work:</p>
<pre><span class=hs-linenum>104: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>foo</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>
<span class=hs-linenum>105: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>forall b c a.
lq_tmp_x625:(lq_tmp_x623:b^"lq_tmp_x154" -&gt; c^"lq_tmp_x155")
-&gt; lq_tmp_x626:(lq_tmp_x624:a^"lq_tmp_x158" -&gt; b^"lq_tmp_x159")
-&gt; lq_tmp_x627:a^"lq_tmp_x161"
-&gt; c^"lq_tmp_x162"</span><span class='hs-definition'>foo</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x623:b^"lq_tmp_x154" -&gt; c^"lq_tmp_x155"</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x624:a^"lq_tmp_x158" -&gt; b^"lq_tmp_x159"</span><span class='hs-varid'>g</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>a^"lq_tmp_x161"</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp_x635:b^"lq_tmp_x154" -&gt; c^"lq_tmp_x155"</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>lq_tmp_x632:a^"lq_tmp_x158" -&gt; b^"lq_tmp_x159"</span><span class='hs-varid'>g</span></a> <a class=annot href="#"><span class=annottext>{VV : a^"lq_tmp_x161" | VV == x#a1ba}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>)</span>
</pre>
<p>(Quick quiz: why do we need the parentheses around <code>g x</code>?)</p>
<p>OK, so what was the point of that? Does <code>foo</code> actually do anything useful or was that just a silly exercise in working with types?</p>
<p>As it turns out, <code>foo</code> is really called <code>(.)</code>, and represents <em>function composition</em>. That is, if <code>f</code> and <code>g</code> are functions, then <code>f . g</code> is the function which does first <code>g</code> and then <code>f</code>.</p>
<p>Function composition can be quite useful in writing concise, elegant code. It fits well in a &quot;wholemeal&quot; style where we think about composing together successive high-level transformations of a data structure.</p>
<p>As an example, consider the following function:</p>
<pre><span class=hs-linenum>123: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>myTest</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Integer</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum>124: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp_x992:[GHC.Integer.Type.Integer^"lq_tmp_x209"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x211"
-&gt; GHC.Types.Bool^"lq_tmp_x212"</span><span class='hs-definition'>myTest</span></a> <a class=annot href="#"><span class=annottext>[GHC.Integer.Type.Integer^"lq_tmp_x209"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x211"</span><span class='hs-varid'>xs</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1028:GHC.Types.Int^"lq_tmp_x1029" "lq_tmp_x72"
-&gt; GHC.Types.Bool^"lq_tmp_x73"</span><span class='hs-varid'>even</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>lq_tmp_x1013:[{lq_tmp_x1017 : GHC.Integer.Type.Integer^"lq_tmp_x1016" | k_1015[VV#1014:=lq_tmp_x1017]}]
-&gt; {lq_tmp_x1011 : GHC.Types.Int | lq_tmp_x1011 == len lq_tmp_x1013}</span><span class='hs-varid'>length</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>lq_tmp_x1003:[GHC.Integer.Type.Integer^"lq_tmp_x202"]&lt;\lq_tmp_x995 VV -&gt; True&gt;^"lq_tmp_x204"
-&gt; [GHC.Integer.Type.Integer^"lq_tmp_x205"]&lt;\lq_tmp_x999 VV -&gt; True&gt;^"lq_tmp_x207"</span><span class='hs-varid'>greaterThan100</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x1007 : [GHC.Integer.Type.Integer^"lq_tmp_x209"]&lt;\lq_tmp_x1005 VV -&gt; True&gt;^"lq_tmp_x211" | len lq_tmp_x1007 &gt;= 0 &amp;&amp; lq_tmp_x1007 == xs#a1bb}</span><span class='hs-varid'>xs</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
</pre>
<p>We can rewrite this as:</p>
<pre><span class=hs-linenum>128: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>myTest'</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Integer</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum>129: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1035:[GHC.Integer.Type.Integer^"lq_tmp_x214"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x216"
-&gt; GHC.Types.Bool^"lq_tmp_x217"</span><span class='hs-definition'>myTest'</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1181:GHC.Types.Int^"lq_tmp_x1042" "lq_tmp_x72"
-&gt; GHC.Types.Bool^"lq_tmp_x73"</span><span class='hs-varid'>even</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x1143:(lq_tmp_x1141:{lq_tmp_x1149 : GHC.Types.Int^"lq_tmp_x1148" | k_1147[VV#1146:=lq_tmp_x1149]}
              -&gt; {lq_tmp_x1153 : GHC.Types.Bool^"lq_tmp_x1152" "lq_tmp_x1175" | k_1151[VV#1150:=lq_tmp_x1153] &amp;&amp; k_1174[lq_tmp_x1176:=lq_tmp_x1141][VV#1173:=lq_tmp_x1153]})
-&gt; lq_tmp_x1144:(lq_tmp_x1142:{lq_tmp_x1167 : [{lq_tmp_x1164 : GHC.Integer.Type.Integer^"lq_tmp_x1156" | k_1155[VV#1154:=lq_tmp_x1164][VV#1161:=lq_tmp_x1167]}]&lt;\lq_tmp_x1165 VV -&gt; k_1159[VV#1158:=lq_tmp_x1166][lq_tmp_x1157:=lq_tmp_x1165]&gt;^"lq_tmp_x1163" | k_1162[VV#1161:=lq_tmp_x1167]}
                 -&gt; {lq_tmp_x1149 : GHC.Types.Int^"lq_tmp_x1148" "lq_tmp_x1170" | k_1147[VV#1146:=lq_tmp_x1149] &amp;&amp; k_1169[lq_tmp_x1171:=lq_tmp_x1142][VV#1168:=lq_tmp_x1149]})
-&gt; lq_tmp_x1145:{lq_tmp_x1167 : [{lq_tmp_x1164 : GHC.Integer.Type.Integer^"lq_tmp_x1156" | k_1155[VV#1154:=lq_tmp_x1164][VV#1161:=lq_tmp_x1167]}]&lt;\lq_tmp_x1165 VV -&gt; k_1159[VV#1158:=lq_tmp_x1166][lq_tmp_x1157:=lq_tmp_x1165]&gt;^"lq_tmp_x1163" | k_1162[VV#1161:=lq_tmp_x1167]}
-&gt; exists [z:{lq_tmp_x1149 : GHC.Types.Int^"lq_tmp_x1148" "lq_tmp_x1170" | k_1147[VV#1146:=lq_tmp_x1149] &amp;&amp; k_1169[lq_tmp_x1171:=lq_tmp_x1145][VV#1168:=lq_tmp_x1149]}].{lq_tmp_x1153 : GHC.Types.Bool^"lq_tmp_x1152" "lq_tmp_x1175" | k_1151[VV#1150:=lq_tmp_x1153] &amp;&amp; k_1174[lq_tmp_x1176:=z][VV#1173:=lq_tmp_x1153]}</span><span class='hs-varop'>.</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x1123:[{lq_tmp_x1117 : GHC.Integer.Type.Integer^"lq_tmp_x1054" | k_1053[VV#1052:=lq_tmp_x1117][lq_tmp_x1055:=lq_tmp_x1117][lq_tmp_x1048:=lq_tmp_x1120]}]
-&gt; {lq_tmp_x1121 : GHC.Types.Int | lq_tmp_x1121 == len lq_tmp_x1123}</span><span class='hs-varid'>length</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x1065:(lq_tmp_x1063:{lq_tmp_x1081 : [{lq_tmp_x1078 : GHC.Integer.Type.Integer^"lq_tmp_x1070" | k_1069[VV#1068:=lq_tmp_x1078][VV#1075:=lq_tmp_x1081]}]&lt;\lq_tmp_x1079 VV -&gt; k_1073[VV#1072:=lq_tmp_x1080][lq_tmp_x1071:=lq_tmp_x1079]&gt;^"lq_tmp_x1077" | k_1076[VV#1075:=lq_tmp_x1081]}
              -&gt; {lq_tmp_x1085 : GHC.Types.Int^"lq_tmp_x1084" "lq_tmp_x1114" | k_1083[VV#1082:=lq_tmp_x1085] &amp;&amp; k_1113[lq_tmp_x1115:=lq_tmp_x1063][VV#1112:=lq_tmp_x1085]})
-&gt; lq_tmp_x1066:(lq_tmp_x1064:{lq_tmp_x1099 : [{lq_tmp_x1096 : GHC.Integer.Type.Integer^"lq_tmp_x1088" | k_1087[VV#1086:=lq_tmp_x1096][VV#1093:=lq_tmp_x1099]}]&lt;\lq_tmp_x1097 VV -&gt; k_1091[VV#1090:=lq_tmp_x1098][lq_tmp_x1089:=lq_tmp_x1097]&gt;^"lq_tmp_x1095" | k_1094[VV#1093:=lq_tmp_x1099]}
                 -&gt; {lq_tmp_x1081 : [{lq_tmp_x1078 : GHC.Integer.Type.Integer^"lq_tmp_x1070" "lq_tmp_x1102" | k_1069[VV#1068:=lq_tmp_x1078][VV#1075:=lq_tmp_x1081] &amp;&amp; k_1101[lq_tmp_x1110:=lq_tmp_x1064][VV#1100:=lq_tmp_x1078]}]&lt;\lq_tmp_x1079 VV -&gt; k_1073[VV#1072:=lq_tmp_x1080][lq_tmp_x1071:=lq_tmp_x1079] &amp;&amp; k_1105[lq_tmp_x1110:=lq_tmp_x1064][VV#1104:=lq_tmp_x1080]&gt;^"lq_tmp_x1077" "lq_tmp_x1109" | k_1076[VV#1075:=lq_tmp_x1081] &amp;&amp; k_1108[lq_tmp_x1110:=lq_tmp_x1064][VV#1107:=lq_tmp_x1081]})
-&gt; lq_tmp_x1067:{lq_tmp_x1099 : [{lq_tmp_x1096 : GHC.Integer.Type.Integer^"lq_tmp_x1088" | k_1087[VV#1086:=lq_tmp_x1096][VV#1093:=lq_tmp_x1099]}]&lt;\lq_tmp_x1097 VV -&gt; k_1091[VV#1090:=lq_tmp_x1098][lq_tmp_x1089:=lq_tmp_x1097]&gt;^"lq_tmp_x1095" | k_1094[VV#1093:=lq_tmp_x1099]}
-&gt; exists [z:{lq_tmp_x1081 : [{lq_tmp_x1078 : GHC.Integer.Type.Integer^"lq_tmp_x1070" "lq_tmp_x1102" | k_1069[VV#1068:=lq_tmp_x1078][VV#1075:=lq_tmp_x1081] &amp;&amp; k_1101[lq_tmp_x1110:=lq_tmp_x1067][VV#1100:=lq_tmp_x1078]}]&lt;\lq_tmp_x1079 VV -&gt; k_1073[VV#1072:=lq_tmp_x1080][lq_tmp_x1071:=lq_tmp_x1079] &amp;&amp; k_1105[lq_tmp_x1110:=lq_tmp_x1067][VV#1104:=lq_tmp_x1080]&gt;^"lq_tmp_x1077" "lq_tmp_x1109" | k_1076[VV#1075:=lq_tmp_x1081] &amp;&amp; k_1108[lq_tmp_x1110:=lq_tmp_x1067][VV#1107:=lq_tmp_x1081]}].{lq_tmp_x1085 : GHC.Types.Int^"lq_tmp_x1084" "lq_tmp_x1114" | k_1083[VV#1082:=lq_tmp_x1085] &amp;&amp; k_1113[lq_tmp_x1115:=z][VV#1112:=lq_tmp_x1085]}</span><span class='hs-varop'>.</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x1133:[GHC.Integer.Type.Integer^"lq_tmp_x202"]&lt;\lq_tmp_x1125 VV -&gt; True&gt;^"lq_tmp_x204"
-&gt; [GHC.Integer.Type.Integer^"lq_tmp_x205"]&lt;\lq_tmp_x1129 VV -&gt; True&gt;^"lq_tmp_x207"</span><span class='hs-varid'>greaterThan100</span></a>
</pre>
<p>This version makes much clearer what is really going on: <code>myTest'</code> is just a &quot;pipeline&quot; composed of three smaller functions. This example also demonstrates why function composition seems &quot;backwards&quot;: it's because function application is backwards! Since we read from left to right, it would make sense to think of values as also flowing from left to right. But in that case we should write \( (x)f \) to denote giving the value \(x\) as an input to the function \(f\). But no thanks to Alexis Claude Clairaut and Euler, we have been stuck with the backwards notation since 1734.</p>
<p>Let's take a closer look at the type of <code>(.)</code>. If we ask <code>ghci</code> for its type, we get</p>
<pre><code>Prelude&gt; :t (.)
(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</code></pre>
<p>Wait a minute. What's going on here? What happened to the parentheses around <code>(a -&gt; c)</code>?</p>
<h2 id="currying-and-partial-application">Currying and partial application</h2>
<p>Remember how the types of multi-argument functions look weird, like they have &quot;extra&quot; arrows in them? For example, consider the function</p>
<pre><span class=hs-linenum>156: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>f</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>157: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp_x675:GHC.Types.Int^"lq_tmp_x169"
-&gt; lq_tmp_x676:GHC.Types.Int^"lq_tmp_x171"
-&gt; GHC.Types.Int^"lq_tmp_x172"</span><span class='hs-definition'>f</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int^"lq_tmp_x169"</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int^"lq_tmp_x171"</span><span class='hs-varid'>y</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x696 : GHC.Types.Int | lq_tmp_x696 == (2  :  int) &amp;&amp; lq_tmp_x696 == lq_anf__d1g8}</span><span class='hs-num'>2</span></a><a class=annot href="#"><span class=annottext>lq_tmp_x690:GHC.Types.Int^"lq_tmp_x692"
-&gt; lq_tmp_x691:GHC.Types.Int^"lq_tmp_x692"
-&gt; {lq_tmp_x693 : GHC.Types.Int^"lq_tmp_x692" | lq_tmp_x690 == 0 || lq_tmp_x691 == 0 =&gt; lq_tmp_x693 == 0 &amp;&amp; lq_tmp_x690 &gt; 0 &amp;&amp; lq_tmp_x691 &gt; 0 =&gt; lq_tmp_x693 &gt;= lq_tmp_x690 &amp;&amp; lq_tmp_x693 &gt;= lq_tmp_x691 &amp;&amp; lq_tmp_x690 &gt; 1 &amp;&amp; lq_tmp_x691 &gt; 1 =&gt; lq_tmp_x693 &gt; lq_tmp_x690 &amp;&amp; lq_tmp_x693 &gt; lq_tmp_x691}</span><span class='hs-varop'>*</span></a><a class=annot href="#"><span class=annottext>{lq_tmp_x697 : GHC.Types.Int^"lq_tmp_x169" | lq_tmp_x697 == x#a1bc}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x704:GHC.Types.Int^"lq_tmp_x706"
-&gt; lq_tmp_x705:GHC.Types.Int^"lq_tmp_x706"
-&gt; {lq_tmp_x707 : GHC.Types.Int^"lq_tmp_x706" | lq_tmp_x707 == lq_tmp_x704 + lq_tmp_x705}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x711 : GHC.Types.Int^"lq_tmp_x171" | lq_tmp_x711 == y#a1bd}</span><span class='hs-varid'>y</span></a>
</pre>
<p>I promised before that there is a beautiful, deep reason for this, and now it's finally time to reveal it: <em>all functions in Haskell take only one argument</em>. Say what?! But doesn't the function <code>f</code> shown above take two arguments? No, actually, it doesn't: it takes one argument (an <code>Int</code>) and <em>outputs a function</em> (of type <code>Int -&gt; Int</code>); that function takes one argument and returns the final answer. In fact, we can equivalently write <code>f</code>'s type like this:</p>
<pre><span class=hs-linenum>167: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>f'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span>
<span class=hs-linenum>168: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp_x637:GHC.Types.Int^"lq_tmp_x164"
-&gt; lq_tmp_x638:GHC.Types.Int^"lq_tmp_x166"
-&gt; GHC.Types.Int^"lq_tmp_x167"</span><span class='hs-definition'>f'</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int^"lq_tmp_x164"</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int^"lq_tmp_x166"</span><span class='hs-varid'>y</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x658 : GHC.Types.Int | lq_tmp_x658 == (2  :  int) &amp;&amp; lq_tmp_x658 == lq_anf__d1g6}</span><span class='hs-num'>2</span></a><a class=annot href="#"><span class=annottext>lq_tmp_x652:GHC.Types.Int^"lq_tmp_x654"
-&gt; lq_tmp_x653:GHC.Types.Int^"lq_tmp_x654"
-&gt; {lq_tmp_x655 : GHC.Types.Int^"lq_tmp_x654" | lq_tmp_x652 == 0 || lq_tmp_x653 == 0 =&gt; lq_tmp_x655 == 0 &amp;&amp; lq_tmp_x652 &gt; 0 &amp;&amp; lq_tmp_x653 &gt; 0 =&gt; lq_tmp_x655 &gt;= lq_tmp_x652 &amp;&amp; lq_tmp_x655 &gt;= lq_tmp_x653 &amp;&amp; lq_tmp_x652 &gt; 1 &amp;&amp; lq_tmp_x653 &gt; 1 =&gt; lq_tmp_x655 &gt; lq_tmp_x652 &amp;&amp; lq_tmp_x655 &gt; lq_tmp_x653}</span><span class='hs-varop'>*</span></a><a class=annot href="#"><span class=annottext>{lq_tmp_x659 : GHC.Types.Int^"lq_tmp_x164" | lq_tmp_x659 == x#a1be}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x666:GHC.Types.Int^"lq_tmp_x668"
-&gt; lq_tmp_x667:GHC.Types.Int^"lq_tmp_x668"
-&gt; {lq_tmp_x669 : GHC.Types.Int^"lq_tmp_x668" | lq_tmp_x669 == lq_tmp_x666 + lq_tmp_x667}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x673 : GHC.Types.Int^"lq_tmp_x166" | lq_tmp_x673 == y#a1bf}</span><span class='hs-varid'>y</span></a>
</pre>
<p>In particular, note that function arrows <em>associate to the right</em>, that is, <code>W -&gt; X -&gt; Y -&gt; Z</code> is equivalent to <code>W -&gt; (X -&gt; (Y -&gt; Z))</code>. We can always add or remove parentheses around the rightmost top-level arrow in a type.</p>
<p>Function application, in turn, is <em>left</em>-associative. That is, <code>f 3 2</code> is really shorthand for <code>(f 3) 2</code>. This makes sense given what we said previously about <code>f</code> actually taking one argument and returning a function: we apply <code>f</code> to an argument <code>3</code>, which returns a function of type <code>Int -&gt; Int</code>, namely, a function which takes an <code>Int</code> and adds 6 to it. We then apply that function to the argument <code>2</code> by writing <code>(f 3) 2</code>, which gives us an <code>Int</code>. Since function application associates to the left, however, we can abbreviate <code>(f 3) 2</code> as <code>f 3 2</code>, giving us a nice notation for <code>f</code> as a &quot;multi-argument&quot; function.</p>
<p>The &quot;multi-argument&quot; lambda abstraction</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">\x y z <span class="ot">-&gt;</span> <span class="fu">...</span> </code></pre>
<p>is really just syntax sugar for</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">\x <span class="ot">-&gt;</span> (\y <span class="ot">-&gt;</span> (\z <span class="ot">-&gt;</span> <span class="fu">...</span>))<span class="fu">.</span>  </code></pre>
<p>Likewise, the function definition</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f x y z <span class="fu">=</span> <span class="fu">...</span> </code></pre>
<p>is syntax sugar for</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="fu">=</span> \x <span class="ot">-&gt;</span> (\y <span class="ot">-&gt;</span> (\z <span class="ot">-&gt;</span> <span class="fu">...</span>))<span class="fu">.</span></code></pre>
<p>Note, for example, that we can rewrite our composition function from above by moving the <code>\x -&gt; ...</code> from the right-hand side of the <code>=</code> to the left-hand side:</p>
<pre><span class=hs-linenum>213: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>comp</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span>
<span class=hs-linenum>214: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>forall b c a.
lq_tmp_x611:(lq_tmp_x609:b^"lq_tmp_x143" -&gt; c^"lq_tmp_x144")
-&gt; lq_tmp_x612:(lq_tmp_x610:a^"lq_tmp_x147" -&gt; b^"lq_tmp_x148")
-&gt; lq_tmp_x613:a^"lq_tmp_x150"
-&gt; c^"lq_tmp_x151"</span><span class='hs-definition'>comp</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x609:b^"lq_tmp_x143" -&gt; c^"lq_tmp_x144"</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x610:a^"lq_tmp_x147" -&gt; b^"lq_tmp_x148"</span><span class='hs-varid'>g</span></a> <a class=annot href="#"><span class=annottext>a^"lq_tmp_x150"</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x621:b^"lq_tmp_x143" -&gt; c^"lq_tmp_x144"</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>lq_tmp_x618:a^"lq_tmp_x147" -&gt; b^"lq_tmp_x148"</span><span class='hs-varid'>g</span></a> <a class=annot href="#"><span class=annottext>{VV : a^"lq_tmp_x150" | VV == x#a1bi}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>)</span>
</pre>
<p>This idea of representing multi-argument functions as one-argument functions returning functions is known as <em>currying</em>, named for the British mathematician and logician Haskell Curry. (His first name might sound familiar; yes, it's the same guy.) Curry lived from 1900-1982 and spent much of his life at Penn State---but he also helped work on ENIAC at UPenn. The idea of representing multi-argument functions as one-argument functions returning functions was actually first discovered by Moses Schönfinkel, so we probably ought to call it <em>schönfinkeling</em>. Curry himself attributed the idea to Schönfinkel, but others had already started calling it &quot;currying&quot; and it was too late.</p>
<p>If we want to actually represent a function of two arguments we can use a single argument which is a tuple. That is, the function</p>
<pre><span class=hs-linenum>231: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>f''</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span><span class='hs-conid'>Int</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>232: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp_x713:(GHC.Types.Int^"lq_tmp_x174", GHC.Types.Int^"lq_tmp_x175")&lt;\fld_Tuple VV -&gt; True&gt;^"lq_tmp_x177"
-&gt; GHC.Types.Int^"lq_tmp_x178"</span><span class='hs-definition'>f''</span></a> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x757 : GHC.Types.Int | lq_tmp_x757 == (2  :  int) &amp;&amp; lq_tmp_x757 == lq_anf__d1gb}</span><span class='hs-num'>2</span></a><a class=annot href="#"><span class=annottext>lq_tmp_x751:GHC.Types.Int^"lq_tmp_x753"
-&gt; lq_tmp_x752:GHC.Types.Int^"lq_tmp_x753"
-&gt; {lq_tmp_x754 : GHC.Types.Int^"lq_tmp_x753" | lq_tmp_x751 == 0 || lq_tmp_x752 == 0 =&gt; lq_tmp_x754 == 0 &amp;&amp; lq_tmp_x751 &gt; 0 &amp;&amp; lq_tmp_x752 &gt; 0 =&gt; lq_tmp_x754 &gt;= lq_tmp_x751 &amp;&amp; lq_tmp_x754 &gt;= lq_tmp_x752 &amp;&amp; lq_tmp_x751 &gt; 1 &amp;&amp; lq_tmp_x752 &gt; 1 =&gt; lq_tmp_x754 &gt; lq_tmp_x751 &amp;&amp; lq_tmp_x754 &gt; lq_tmp_x752}</span><span class='hs-varop'>*</span></a><a class=annot href="#"><span class=annottext>{lq_tmp_x758 : GHC.Types.Int^"lq_tmp_x174" | lq_tmp_x758 == x#a1bj}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x765:GHC.Types.Int^"lq_tmp_x767"
-&gt; lq_tmp_x766:GHC.Types.Int^"lq_tmp_x767"
-&gt; {lq_tmp_x768 : GHC.Types.Int^"lq_tmp_x767" | lq_tmp_x768 == lq_tmp_x765 + lq_tmp_x766}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x772 : GHC.Types.Int^"lq_tmp_x175" "lq_tmp_x176" | lq_tmp_x772 == y#a1bk}</span><span class='hs-varid'>y</span></a>
</pre>
<p>can also be thought of as taking &quot;two arguments&quot;, although in another sense it really only takes one argument which happens to be a pair. In order to convert between the two representations of a two-argument function, the standard library defines functions called <code>curry</code> and <code>uncurry</code>, defined like this (except with different names):</p>
<pre><span class=hs-linenum>240: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>schönfinkel</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span>
<span class=hs-linenum>241: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>forall a b c.
lq_tmp_x578:(lq_tmp_x577:(a^"lq_tmp_x131", b^"lq_tmp_x132")&lt;\fld_Tuple VV -&gt; True&gt;^"lq_tmp_x134"
             -&gt; c^"lq_tmp_x135")
-&gt; lq_tmp_x579:a^"lq_tmp_x137"
-&gt; lq_tmp_x580:b^"lq_tmp_x139"
-&gt; c^"lq_tmp_x140"</span><span class='hs-definition'>schönfinkel</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x577:(a^"lq_tmp_x131", b^"lq_tmp_x132")&lt;\fld_Tuple VV -&gt; True&gt;^"lq_tmp_x134"
-&gt; c^"lq_tmp_x135"</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>a^"lq_tmp_x137"</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>b^"lq_tmp_x139"</span><span class='hs-varid'>y</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x605:(a^"lq_tmp_x131", b^"lq_tmp_x132")&lt;\lq_tmp_x602 VV -&gt; True&gt;^"lq_tmp_x134"
-&gt; c^"lq_tmp_x135"</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x607 : ({VV#590 : a^"lq_tmp_x592" | k_591[lq_tmp_x588:=x#a1bm][lq_tmp_x589:=y#a1bn][lq_tmp_x585:=lq_tmp_x607]}, {VV#593 : b^"lq_tmp_x595" | k_594[lq_tmp_x588:=x#a1bm][lq_tmp_x589:=y#a1bn][lq_tmp_x585:=lq_tmp_x607]})&lt;\lq_tmp_x606 VV -&gt; k_597[lq_tmp_x599:=lq_tmp_x606][VV#596:=VV#593][lq_tmp_x588:=x#a1bm][lq_tmp_x589:=y#a1bn][lq_tmp_x584:=lq_tmp_x606]&gt; | snd lq_tmp_x607 == y#a1bn &amp;&amp; fst lq_tmp_x607 == x#a1bm &amp;&amp; x_Tuple22 lq_tmp_x607 == y#a1bn &amp;&amp; x_Tuple21 lq_tmp_x607 == x#a1bm &amp;&amp; lq_tmp_x607 == lq_anf__d1g3}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{VV : a^"lq_tmp_x137" | VV == x#a1bm}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>,</span><a class=annot href="#"><span class=annottext>{VV : b^"lq_tmp_x139" | VV == y#a1bn}</span><span class='hs-varid'>y</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>242: </span><span class='hs-varop'>&gt;</span>
<span class=hs-linenum>243: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>unschönfinkel</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span>
<span class=hs-linenum>244: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>forall a b c.
lq_tmp_x549:(lq_tmp_x547:a^"lq_tmp_x119"
             -&gt; lq_tmp_x548:b^"lq_tmp_x121" -&gt; c^"lq_tmp_x122")
-&gt; lq_tmp_x550:(a^"lq_tmp_x124", b^"lq_tmp_x125")&lt;\fld_Tuple VV -&gt; True&gt;^"lq_tmp_x127"
-&gt; c^"lq_tmp_x128"</span><span class='hs-definition'>unschönfinkel</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x547:a^"lq_tmp_x119"
-&gt; lq_tmp_x548:b^"lq_tmp_x121" -&gt; c^"lq_tmp_x122"</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x574:a^"lq_tmp_x119"
-&gt; lq_tmp_x575:b^"lq_tmp_x121" -&gt; c^"lq_tmp_x122"</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{VV : a^"lq_tmp_x124" | VV == x#a1bp}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{VV : b^"lq_tmp_x125" "lq_tmp_x126" | VV == y#a1bq}</span><span class='hs-varid'>y</span></a>
</pre>
<p><code>uncurry</code> in particular can be useful when you have a pair and want to apply a function to it. For example:</p>
<pre><code>Prelude&gt; uncurry (+) (2,3)
5</code></pre>
<p><strong>Partial application</strong></p>
<p>The fact that functions in Haskell are curried makes <em>partial application</em> particularly easy. The idea of partial application is that we can take a function of multiple arguments and apply it to just <em>some</em> of its arguments, and get out a function of the remaining arguments. But as we've just seen, in Haskell there <em>are no</em> functions of multiple arguments! Every function can be &quot;partially applied&quot; to its first (and only) argument, resulting in a function of the remaining arguments.</p>
<p>Note that Haskell doesn't make it easy to partially apply to an argument other than the first. The one exception is infix operators, which as we've seen, can be partially applied to either of their two arguments using an operator section. In practice this is not that big of a restriction. There is an art to deciding the order of arguments to a function to make partial applications of it as useful as possible: the arguments should be ordered from from &quot;least to greatest variation&quot;, that is, arguments which will often be the same should be listed first, and arguments which will often be different should come last.</p>
<p><strong>Wholemeal programming</strong></p>
<p>Let's put some of the things we've just learned together in an example that also shows the power of a &quot;wholemeal&quot; style of programming. Consider the function <code>foobar</code>, defined as follows:</p>
<pre><span class=hs-linenum>280: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>foobar</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Integer</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Integer</span>
<span class=hs-linenum>281: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1562:[GHC.Integer.Type.Integer^"lq_tmp_x229"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x231"
-&gt; GHC.Integer.Type.Integer^"lq_tmp_x232"</span><span class='hs-definition'>foobar</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<span class=hs-linenum>282: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>foobar</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span>
<span class=hs-linenum>283: </span><span class='hs-varop'>&gt;</span>   <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x1619 : GHC.Integer.Type.Integer^"lq_tmp_x229" | lq_tmp_x1619 == x#a1br}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x1611:{lq_tmp_x1616 : GHC.Integer.Type.Integer^"lq_tmp_x1615" | k_1614[VV#1613:=lq_tmp_x1616][lq_tmp_x1610:=fix#GHC.Integer.Type.#36#fOrdInteger#35#rhv]}
-&gt; lq_tmp_x1612:{lq_tmp_x1616 : GHC.Integer.Type.Integer^"lq_tmp_x1615" | k_1614[VV#1613:=lq_tmp_x1616][lq_tmp_x1610:=fix#GHC.Integer.Type.#36#fOrdInteger#35#rhv]}
-&gt; {lq_tmp_x1606 : GHC.Types.Bool | Prop lq_tmp_x1606 &lt;=&gt; lq_tmp_x1611 &gt; lq_tmp_x1612}</span><span class='hs-varop'>&gt;</span></a> <span class='hs-num'>3</span>     <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{lq_tmp_x1679 : GHC.Integer.Type.Integer^"lq_tmp_x1659" | lq_anf__d1gE == 0 || x#a1br == 0 =&gt; lq_tmp_x1679 == 0 &amp;&amp; lq_anf__d1gE &gt; 0 &amp;&amp; x#a1br &gt; 0 =&gt; lq_tmp_x1679 &gt;= lq_anf__d1gE &amp;&amp; lq_tmp_x1679 &gt;= x#a1br &amp;&amp; lq_anf__d1gE &gt; 1 &amp;&amp; x#a1br &gt; 1 =&gt; lq_tmp_x1679 &gt; lq_anf__d1gE &amp;&amp; lq_tmp_x1679 &gt; x#a1br &amp;&amp; lq_tmp_x1679 == lq_anf__d1gF}</span><span class='hs-num'>7</span></a><a class=annot href="#"><span class=annottext>lq_tmp_x1657:GHC.Integer.Type.Integer^"lq_tmp_x1659"
-&gt; lq_tmp_x1658:GHC.Integer.Type.Integer^"lq_tmp_x1659"
-&gt; {lq_tmp_x1660 : GHC.Integer.Type.Integer^"lq_tmp_x1659" | lq_tmp_x1657 == 0 || lq_tmp_x1658 == 0 =&gt; lq_tmp_x1660 == 0 &amp;&amp; lq_tmp_x1657 &gt; 0 &amp;&amp; lq_tmp_x1658 &gt; 0 =&gt; lq_tmp_x1660 &gt;= lq_tmp_x1657 &amp;&amp; lq_tmp_x1660 &gt;= lq_tmp_x1658 &amp;&amp; lq_tmp_x1657 &gt; 1 &amp;&amp; lq_tmp_x1658 &gt; 1 =&gt; lq_tmp_x1660 &gt; lq_tmp_x1657 &amp;&amp; lq_tmp_x1660 &gt; lq_tmp_x1658}</span><span class='hs-varop'>*</span></a><a class=annot href="#"><span class=annottext>{lq_tmp_x1664 : GHC.Integer.Type.Integer^"lq_tmp_x229" | lq_tmp_x1664 == x#a1br}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x1673:GHC.Integer.Type.Integer^"lq_tmp_x1675"
-&gt; lq_tmp_x1674:GHC.Integer.Type.Integer^"lq_tmp_x1675"
-&gt; {lq_tmp_x1676 : GHC.Integer.Type.Integer^"lq_tmp_x1675" | lq_tmp_x1676 == lq_tmp_x1673 + lq_tmp_x1674}</span><span class='hs-varop'>+</span></a> <span class='hs-num'>2</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1699:GHC.Integer.Type.Integer^"lq_tmp_x1701"
-&gt; lq_tmp_x1700:GHC.Integer.Type.Integer^"lq_tmp_x1701"
-&gt; {lq_tmp_x1702 : GHC.Integer.Type.Integer^"lq_tmp_x1701" | lq_tmp_x1702 == lq_tmp_x1699 + lq_tmp_x1700}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x1562:[GHC.Integer.Type.Integer^"lq_tmp_x229"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x231"
-&gt; GHC.Integer.Type.Integer^"lq_tmp_x232"</span><span class='hs-varid'>foobar</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x1692 : [GHC.Integer.Type.Integer^"lq_tmp_x229" "lq_tmp_x230"]&lt;\lq_tmp_x1690 VV -&gt; True&gt; | len lq_tmp_x1692 &gt;= 0 &amp;&amp; lq_tmp_x1692 == xs#a1bs}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>284: </span><span class='hs-varop'>&gt;</span>   <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1562:[GHC.Integer.Type.Integer^"lq_tmp_x229"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x231"
-&gt; GHC.Integer.Type.Integer^"lq_tmp_x232"</span><span class='hs-varid'>foobar</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x1643 : [GHC.Integer.Type.Integer^"lq_tmp_x229" "lq_tmp_x230"]&lt;\lq_tmp_x1641 VV -&gt; True&gt; | len lq_tmp_x1643 &gt;= 0 &amp;&amp; lq_tmp_x1643 == xs#a1bs}</span><span class='hs-varid'>xs</span></a>
</pre>
<p>This seems straightforward enough, but it is not good Haskell style. The problem is that it is</p>
<ul>
<li>doing too much at once; and</li>
<li>working at too low of a level.</li>
</ul>
<p>Instead of thinking about what we want to do with each element, we can instead think about making incremental transformations to the entire input, using the existing recursion patterns that we know of. Here's a much more idiomatic implementation of <code>foobar</code>:</p>
<pre><span class=hs-linenum>297: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>foobar'</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Integer</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Integer</span>
<span class=hs-linenum>298: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1262:[GHC.Integer.Type.Integer^"lq_tmp_x224"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x226"
-&gt; GHC.Integer.Type.Integer^"lq_tmp_x227"</span><span class='hs-definition'>foobar'</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1544:[GHC.Integer.Type.Integer^"lq_tmp_x1270" "lq_tmp_x93"]&lt;\lq_tmp_x1539 VV -&gt; True&gt;^"lq_tmp_x95"
-&gt; GHC.Integer.Type.Integer^"lq_tmp_x1270" "lq_tmp_x96"</span><span class='hs-varid'>sum</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x1486:(lq_tmp_x1484:{lq_tmp_x1502 : [{lq_tmp_x1499 : GHC.Integer.Type.Integer^"lq_tmp_x1491" | k_1490[VV#1489:=lq_tmp_x1499][VV#1496:=lq_tmp_x1502]}]&lt;\lq_tmp_x1500 VV -&gt; k_1494[VV#1493:=lq_tmp_x1501][lq_tmp_x1492:=lq_tmp_x1500]&gt;^"lq_tmp_x1498" | k_1497[VV#1496:=lq_tmp_x1502]}
              -&gt; {lq_tmp_x1506 : GHC.Integer.Type.Integer^"lq_tmp_x1505" "lq_tmp_x1535" | k_1504[VV#1503:=lq_tmp_x1506] &amp;&amp; k_1534[lq_tmp_x1536:=lq_tmp_x1484][VV#1533:=lq_tmp_x1506]})
-&gt; lq_tmp_x1487:(lq_tmp_x1485:{lq_tmp_x1520 : [{lq_tmp_x1517 : GHC.Integer.Type.Integer^"lq_tmp_x1509" | k_1508[VV#1507:=lq_tmp_x1517][VV#1514:=lq_tmp_x1520]}]&lt;\lq_tmp_x1518 VV -&gt; k_1512[VV#1511:=lq_tmp_x1519][lq_tmp_x1510:=lq_tmp_x1518]&gt;^"lq_tmp_x1516" | k_1515[VV#1514:=lq_tmp_x1520]}
                 -&gt; {lq_tmp_x1502 : [{lq_tmp_x1499 : GHC.Integer.Type.Integer^"lq_tmp_x1491" "lq_tmp_x1523" | k_1490[VV#1489:=lq_tmp_x1499][VV#1496:=lq_tmp_x1502] &amp;&amp; k_1522[lq_tmp_x1531:=lq_tmp_x1485][VV#1521:=lq_tmp_x1499]}]&lt;\lq_tmp_x1500 VV -&gt; k_1494[VV#1493:=lq_tmp_x1501][lq_tmp_x1492:=lq_tmp_x1500] &amp;&amp; k_1526[lq_tmp_x1531:=lq_tmp_x1485][VV#1525:=lq_tmp_x1501]&gt;^"lq_tmp_x1498" "lq_tmp_x1530" | k_1497[VV#1496:=lq_tmp_x1502] &amp;&amp; k_1529[lq_tmp_x1531:=lq_tmp_x1485][VV#1528:=lq_tmp_x1502]})
-&gt; lq_tmp_x1488:{lq_tmp_x1520 : [{lq_tmp_x1517 : GHC.Integer.Type.Integer^"lq_tmp_x1509" | k_1508[VV#1507:=lq_tmp_x1517][VV#1514:=lq_tmp_x1520]}]&lt;\lq_tmp_x1518 VV -&gt; k_1512[VV#1511:=lq_tmp_x1519][lq_tmp_x1510:=lq_tmp_x1518]&gt;^"lq_tmp_x1516" | k_1515[VV#1514:=lq_tmp_x1520]}
-&gt; exists [z:{lq_tmp_x1502 : [{lq_tmp_x1499 : GHC.Integer.Type.Integer^"lq_tmp_x1491" "lq_tmp_x1523" | k_1490[VV#1489:=lq_tmp_x1499][VV#1496:=lq_tmp_x1502] &amp;&amp; k_1522[lq_tmp_x1531:=lq_tmp_x1488][VV#1521:=lq_tmp_x1499]}]&lt;\lq_tmp_x1500 VV -&gt; k_1494[VV#1493:=lq_tmp_x1501][lq_tmp_x1492:=lq_tmp_x1500] &amp;&amp; k_1526[lq_tmp_x1531:=lq_tmp_x1488][VV#1525:=lq_tmp_x1501]&gt;^"lq_tmp_x1498" "lq_tmp_x1530" | k_1497[VV#1496:=lq_tmp_x1502] &amp;&amp; k_1529[lq_tmp_x1531:=lq_tmp_x1488][VV#1528:=lq_tmp_x1502]}].{lq_tmp_x1506 : GHC.Integer.Type.Integer^"lq_tmp_x1505" "lq_tmp_x1535" | k_1504[VV#1503:=lq_tmp_x1506] &amp;&amp; k_1534[lq_tmp_x1536:=z][VV#1533:=lq_tmp_x1506]}</span><span class='hs-varop'>.</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x1322:(lq_tmp_x1321:{lq_tmp_x1327 : GHC.Integer.Type.Integer^"lq_tmp_x1326" | k_1325[VV#1324:=lq_tmp_x1327]}
              -&gt; {lq_tmp_x1331 : GHC.Integer.Type.Integer^"lq_tmp_x1330" | k_1329[VV#1328:=lq_tmp_x1331]})
-&gt; lq_tmp_x1323:[{lq_tmp_x1327 : GHC.Integer.Type.Integer^"lq_tmp_x1326" | k_1325[VV#1324:=lq_tmp_x1327]}]
-&gt; {lq_tmp_x1318 : [{lq_tmp_x1331 : GHC.Integer.Type.Integer^"lq_tmp_x1330" | k_1329[VV#1328:=lq_tmp_x1331]}] | len lq_tmp_x1318 == len lq_tmp_x1323}</span><span class='hs-varid'>map</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>lq_tmp_x1335:{lq_tmp_x1332 : GHC.Integer.Type.Integer^"lq_tmp_x1277" | k_1276[VV#1275:=lq_tmp_x1332]}
-&gt; {lq_tmp_x1333 : GHC.Integer.Type.Integer^"lq_tmp_x1281" | k_1280[VV#1279:=lq_tmp_x1333][x#a1bt:=lq_tmp_x1335]}</span><span class='hs-keyglyph'>\</span></a><a class=annot href="#"><span class=annottext>{VV#1275 : GHC.Integer.Type.Integer^"lq_tmp_x1277" | k_1276}</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x1311 : GHC.Integer.Type.Integer^"lq_tmp_x1291" | lq_anf__d1gs == 0 || x#a1bt == 0 =&gt; lq_tmp_x1311 == 0 &amp;&amp; lq_anf__d1gs &gt; 0 &amp;&amp; x#a1bt &gt; 0 =&gt; lq_tmp_x1311 &gt;= lq_anf__d1gs &amp;&amp; lq_tmp_x1311 &gt;= x#a1bt &amp;&amp; lq_anf__d1gs &gt; 1 &amp;&amp; x#a1bt &gt; 1 =&gt; lq_tmp_x1311 &gt; lq_anf__d1gs &amp;&amp; lq_tmp_x1311 &gt; x#a1bt &amp;&amp; lq_tmp_x1311 == lq_anf__d1gt}</span><span class='hs-num'>7</span></a><a class=annot href="#"><span class=annottext>lq_tmp_x1289:GHC.Integer.Type.Integer^"lq_tmp_x1291"
-&gt; lq_tmp_x1290:GHC.Integer.Type.Integer^"lq_tmp_x1291"
-&gt; {lq_tmp_x1292 : GHC.Integer.Type.Integer^"lq_tmp_x1291" | lq_tmp_x1289 == 0 || lq_tmp_x1290 == 0 =&gt; lq_tmp_x1292 == 0 &amp;&amp; lq_tmp_x1289 &gt; 0 &amp;&amp; lq_tmp_x1290 &gt; 0 =&gt; lq_tmp_x1292 &gt;= lq_tmp_x1289 &amp;&amp; lq_tmp_x1292 &gt;= lq_tmp_x1290 &amp;&amp; lq_tmp_x1289 &gt; 1 &amp;&amp; lq_tmp_x1290 &gt; 1 =&gt; lq_tmp_x1292 &gt; lq_tmp_x1289 &amp;&amp; lq_tmp_x1292 &gt; lq_tmp_x1290}</span><span class='hs-varop'>*</span></a><a class=annot href="#"><span class=annottext>{lq_tmp_x1296 : GHC.Integer.Type.Integer^"lq_tmp_x1277" | k_1276[VV#1275:=lq_tmp_x1296] &amp;&amp; lq_tmp_x1296 == x#a1bt}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x1305:GHC.Integer.Type.Integer^"lq_tmp_x1307"
-&gt; lq_tmp_x1306:GHC.Integer.Type.Integer^"lq_tmp_x1307"
-&gt; {lq_tmp_x1308 : GHC.Integer.Type.Integer^"lq_tmp_x1307" | lq_tmp_x1308 == lq_tmp_x1305 + lq_tmp_x1306}</span><span class='hs-varop'>+</span></a> <span class='hs-num'>2</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1388:(lq_tmp_x1386:{lq_tmp_x1404 : [{lq_tmp_x1401 : GHC.Integer.Type.Integer^"lq_tmp_x1393" | k_1392[VV#1391:=lq_tmp_x1401][VV#1398:=lq_tmp_x1404]}]&lt;\lq_tmp_x1402 VV -&gt; k_1396[VV#1395:=lq_tmp_x1403][lq_tmp_x1394:=lq_tmp_x1402]&gt;^"lq_tmp_x1400" | k_1399[VV#1398:=lq_tmp_x1404]}
              -&gt; {lq_tmp_x1418 : [{lq_tmp_x1415 : GHC.Integer.Type.Integer^"lq_tmp_x1407" "lq_tmp_x1447" | k_1406[VV#1405:=lq_tmp_x1415][VV#1412:=lq_tmp_x1418] &amp;&amp; k_1446[lq_tmp_x1455:=lq_tmp_x1386][VV#1445:=lq_tmp_x1415]}]&lt;\lq_tmp_x1416 VV -&gt; k_1410[VV#1409:=lq_tmp_x1417][lq_tmp_x1408:=lq_tmp_x1416] &amp;&amp; k_1450[lq_tmp_x1455:=lq_tmp_x1386][VV#1449:=lq_tmp_x1417]&gt;^"lq_tmp_x1414" "lq_tmp_x1454" | k_1413[VV#1412:=lq_tmp_x1418] &amp;&amp; k_1453[lq_tmp_x1455:=lq_tmp_x1386][VV#1452:=lq_tmp_x1418]})
-&gt; lq_tmp_x1389:(lq_tmp_x1387:{lq_tmp_x1432 : [{lq_tmp_x1429 : GHC.Integer.Type.Integer^"lq_tmp_x1421" | k_1420[VV#1419:=lq_tmp_x1429][VV#1426:=lq_tmp_x1432]}]&lt;\lq_tmp_x1430 VV -&gt; k_1424[VV#1423:=lq_tmp_x1431][lq_tmp_x1422:=lq_tmp_x1430]&gt;^"lq_tmp_x1428" | k_1427[VV#1426:=lq_tmp_x1432]}
                 -&gt; {lq_tmp_x1404 : [{lq_tmp_x1401 : GHC.Integer.Type.Integer^"lq_tmp_x1393" "lq_tmp_x1435" | k_1392[VV#1391:=lq_tmp_x1401][VV#1398:=lq_tmp_x1404] &amp;&amp; k_1434[lq_tmp_x1443:=lq_tmp_x1387][VV#1433:=lq_tmp_x1401]}]&lt;\lq_tmp_x1402 VV -&gt; k_1396[VV#1395:=lq_tmp_x1403][lq_tmp_x1394:=lq_tmp_x1402] &amp;&amp; k_1438[lq_tmp_x1443:=lq_tmp_x1387][VV#1437:=lq_tmp_x1403]&gt;^"lq_tmp_x1400" "lq_tmp_x1442" | k_1399[VV#1398:=lq_tmp_x1404] &amp;&amp; k_1441[lq_tmp_x1443:=lq_tmp_x1387][VV#1440:=lq_tmp_x1404]})
-&gt; lq_tmp_x1390:{lq_tmp_x1432 : [{lq_tmp_x1429 : GHC.Integer.Type.Integer^"lq_tmp_x1421" | k_1420[VV#1419:=lq_tmp_x1429][VV#1426:=lq_tmp_x1432]}]&lt;\lq_tmp_x1430 VV -&gt; k_1424[VV#1423:=lq_tmp_x1431][lq_tmp_x1422:=lq_tmp_x1430]&gt;^"lq_tmp_x1428" | k_1427[VV#1426:=lq_tmp_x1432]}
-&gt; exists [z:{lq_tmp_x1404 : [{lq_tmp_x1401 : GHC.Integer.Type.Integer^"lq_tmp_x1393" "lq_tmp_x1435" | k_1392[VV#1391:=lq_tmp_x1401][VV#1398:=lq_tmp_x1404] &amp;&amp; k_1434[lq_tmp_x1443:=lq_tmp_x1390][VV#1433:=lq_tmp_x1401]}]&lt;\lq_tmp_x1402 VV -&gt; k_1396[VV#1395:=lq_tmp_x1403][lq_tmp_x1394:=lq_tmp_x1402] &amp;&amp; k_1438[lq_tmp_x1443:=lq_tmp_x1390][VV#1437:=lq_tmp_x1403]&gt;^"lq_tmp_x1400" "lq_tmp_x1442" | k_1399[VV#1398:=lq_tmp_x1404] &amp;&amp; k_1441[lq_tmp_x1443:=lq_tmp_x1390][VV#1440:=lq_tmp_x1404]}].{lq_tmp_x1418 : [{lq_tmp_x1415 : GHC.Integer.Type.Integer^"lq_tmp_x1407" "lq_tmp_x1447" | k_1406[VV#1405:=lq_tmp_x1415][VV#1412:=lq_tmp_x1418] &amp;&amp; k_1446[lq_tmp_x1455:=z][VV#1445:=lq_tmp_x1415]}]&lt;\lq_tmp_x1416 VV -&gt; k_1410[VV#1409:=lq_tmp_x1417][lq_tmp_x1408:=lq_tmp_x1416] &amp;&amp; k_1450[lq_tmp_x1455:=z][VV#1449:=lq_tmp_x1417]&gt;^"lq_tmp_x1414" "lq_tmp_x1454" | k_1413[VV#1412:=lq_tmp_x1418] &amp;&amp; k_1453[lq_tmp_x1455:=z][VV#1452:=lq_tmp_x1418]}</span><span class='hs-varop'>.</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x1369:(lq_tmp_x1368:{lq_tmp_x1374 : GHC.Integer.Type.Integer^"lq_tmp_x1373" | k_1372[VV#1371:=lq_tmp_x1374]}
              -&gt; GHC.Types.Bool)
-&gt; lq_tmp_x1370:[{lq_tmp_x1374 : GHC.Integer.Type.Integer^"lq_tmp_x1373" | k_1372[VV#1371:=lq_tmp_x1374]}]
-&gt; {lq_tmp_x1365 : [{lq_tmp_x1374 : GHC.Integer.Type.Integer^"lq_tmp_x1373" | k_1372[VV#1371:=lq_tmp_x1374]}] | len lq_tmp_x1365 &lt;= len lq_tmp_x1370}</span><span class='hs-varid'>filter</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>lq_tmp_x1349:{lq_tmp_x1354 : GHC.Integer.Type.Integer^"lq_tmp_x1353" | k_1352[VV#1351:=lq_tmp_x1354][lq_tmp_x1348:=fix#GHC.Integer.Type.#36#fOrdInteger#35#rhv]}
-&gt; lq_tmp_x1350:{lq_tmp_x1354 : GHC.Integer.Type.Integer^"lq_tmp_x1353" | k_1352[VV#1351:=lq_tmp_x1354][lq_tmp_x1348:=fix#GHC.Integer.Type.#36#fOrdInteger#35#rhv]}
-&gt; {lq_tmp_x1344 : GHC.Types.Bool | Prop lq_tmp_x1344 &lt;=&gt; lq_tmp_x1349 &gt; lq_tmp_x1350}</span><span class='hs-varop'>&gt;</span></a><span class='hs-num'>3</span><span class='hs-layout'>)</span>
</pre>
<p>This defines <code>foobar'</code> as a &quot;pipeline&quot; of three functions: first, we throw away all elements from the list which are not greater than three; next, we apply an arithmetic operation to every element of the remaining list; finally, we sum the results.</p>
<p>Notice that in the above example, <code>map</code> and <code>filter</code> have been partially applied. For example, the type of <code>filter</code> is</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</code></pre>
<p>Applying it to <code>(&gt;3)</code> (which has type <code>Integer -&gt; Bool</code>) results in a function of type <code>[Integer] -&gt; [Integer]</code>, which is exactly the right sort of thing to compose with another function on <code>[Integer]</code>.</p>
<p>This style of coding in which we define a function without reference to its arguments---in some sense saying what a function <em>is</em> rather than what it <em>does</em>---is known as &quot;point-free&quot; style. As we can see from the above example, it can be quite beautiful. Some people might even go so far as to say that you should always strive to use point-free style; but taken too far it can become extremely confusing. <code>lambdabot</code> in the <code>#haskell</code> IRC channel has a command <code>@pl</code> for turning functions into equivalent point-free expressions; here's an example:</p>
<pre><code>@pl \f g x y -&gt; f (x ++ g x) (g y)
join . ((flip . ((.) .)) .) . (. ap (++)) . (.)</code></pre>
<p>This is clearly <em>not</em> an improvement!</p>
<h2 id="folds">Folds</h2>
<p>We have one more recursion pattern on lists to talk about: folds. Here are a few functions on lists that follow a similar pattern: all of them somehow &quot;combine&quot; the elements of the list into a final answer.</p>
<pre><span class=hs-linenum>339: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>sum'</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Integer</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Integer</span>
<span class=hs-linenum>340: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1196:[GHC.Integer.Type.Integer^"lq_tmp_x219"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x221"
-&gt; GHC.Integer.Type.Integer^"lq_tmp_x222"</span><span class='hs-definition'>sum'</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<span class=hs-linenum>341: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>sum'</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x1260 : GHC.Integer.Type.Integer^"lq_tmp_x219" | lq_tmp_x1260 == x#a1bu}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x1254:GHC.Integer.Type.Integer^"lq_tmp_x1256"
-&gt; lq_tmp_x1255:GHC.Integer.Type.Integer^"lq_tmp_x1256"
-&gt; {lq_tmp_x1257 : GHC.Integer.Type.Integer^"lq_tmp_x1256" | lq_tmp_x1257 == lq_tmp_x1254 + lq_tmp_x1255}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x1196:[GHC.Integer.Type.Integer^"lq_tmp_x219"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x221"
-&gt; GHC.Integer.Type.Integer^"lq_tmp_x222"</span><span class='hs-varid'>sum'</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x1247 : [GHC.Integer.Type.Integer^"lq_tmp_x219" "lq_tmp_x220"]&lt;\lq_tmp_x1245 VV -&gt; True&gt; | len lq_tmp_x1247 &gt;= 0 &amp;&amp; lq_tmp_x1247 == xs#a1bv}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>342: </span><span class='hs-varop'>&gt;</span>
<span class=hs-linenum>343: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>product'</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Integer</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Integer</span>
<span class=hs-linenum>344: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1708:[GHC.Integer.Type.Integer^"lq_tmp_x234"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x236"
-&gt; GHC.Integer.Type.Integer^"lq_tmp_x237"</span><span class='hs-definition'>product'</span></a> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<span class=hs-linenum>345: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>product'</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x1772 : GHC.Integer.Type.Integer^"lq_tmp_x234" | lq_tmp_x1772 == x#a1bw}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x1766:GHC.Integer.Type.Integer^"lq_tmp_x1768"
-&gt; lq_tmp_x1767:GHC.Integer.Type.Integer^"lq_tmp_x1768"
-&gt; {lq_tmp_x1769 : GHC.Integer.Type.Integer^"lq_tmp_x1768" | lq_tmp_x1766 == 0 || lq_tmp_x1767 == 0 =&gt; lq_tmp_x1769 == 0 &amp;&amp; lq_tmp_x1766 &gt; 0 &amp;&amp; lq_tmp_x1767 &gt; 0 =&gt; lq_tmp_x1769 &gt;= lq_tmp_x1766 &amp;&amp; lq_tmp_x1769 &gt;= lq_tmp_x1767 &amp;&amp; lq_tmp_x1766 &gt; 1 &amp;&amp; lq_tmp_x1767 &gt; 1 =&gt; lq_tmp_x1769 &gt; lq_tmp_x1766 &amp;&amp; lq_tmp_x1769 &gt; lq_tmp_x1767}</span><span class='hs-varop'>*</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x1708:[GHC.Integer.Type.Integer^"lq_tmp_x234"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x236"
-&gt; GHC.Integer.Type.Integer^"lq_tmp_x237"</span><span class='hs-varid'>product'</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x1759 : [GHC.Integer.Type.Integer^"lq_tmp_x234" "lq_tmp_x235"]&lt;\lq_tmp_x1757 VV -&gt; True&gt; | len lq_tmp_x1759 &gt;= 0 &amp;&amp; lq_tmp_x1759 == xs#a1bx}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>346: </span><span class='hs-varop'>&gt;</span>
<span class=hs-linenum>347: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>length'</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>348: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>forall a.
lq_tmp_x775:[a^"lq_tmp_x180"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x182"
-&gt; GHC.Types.Int^"lq_tmp_x183"</span><span class='hs-definition'>length'</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x792:GHC.Prim.Int#
-&gt; {lq_tmp_x790 : GHC.Types.Int | lq_tmp_x790 == (lq_tmp_x792  :  int)}</span><span class='hs-num'>0</span></a>
<span class=hs-linenum>349: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>length'</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x842 : GHC.Types.Int | lq_tmp_x842 == (1  :  int) &amp;&amp; lq_tmp_x842 == lq_anf__d1ge}</span><span class='hs-num'>1</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x836:GHC.Types.Int^"lq_tmp_x838"
-&gt; lq_tmp_x837:GHC.Types.Int^"lq_tmp_x838"
-&gt; {lq_tmp_x839 : GHC.Types.Int^"lq_tmp_x838" | lq_tmp_x839 == lq_tmp_x836 + lq_tmp_x837}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>forall a.
lq_tmp_x775:[a^"lq_tmp_x180"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x182"
-&gt; GHC.Types.Int^"lq_tmp_x183"</span><span class='hs-varid'>length'</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x829 : [a^"lq_tmp_x180" "lq_tmp_x181"]&lt;\lq_tmp_x828 VV -&gt; True&gt; | len lq_tmp_x829 &gt;= 0 &amp;&amp; lq_tmp_x829 == xs#a1by}</span><span class='hs-varid'>xs</span></a>
</pre>
<p>What do these three functions have in common, and what is different? As usual, the idea will be to abstract out the parts that vary, aided by the ability to define higher-order functions.</p>
<pre><span class=hs-linenum>355: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>fold</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span>
<span class=hs-linenum>356: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>forall b a.
lq_tmp_x480:b^"lq_tmp_x105"
-&gt; lq_tmp_x481:(lq_tmp_x478:a^"lq_tmp_x108"
                -&gt; lq_tmp_x479:b^"lq_tmp_x110" -&gt; b^"lq_tmp_x111")
-&gt; lq_tmp_x482:[a^"lq_tmp_x113"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x115"
-&gt; b^"lq_tmp_x116"</span><span class='hs-definition'>fold</span></a> <a class=annot href="#"><span class=annottext>b^"lq_tmp_x105"</span><span class='hs-varid'>z</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x478:a^"lq_tmp_x108"
-&gt; lq_tmp_x479:b^"lq_tmp_x110" -&gt; b^"lq_tmp_x111"</span><span class='hs-varid'>f</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : b^"lq_tmp_x105" | VV == z#a1bz}</span><span class='hs-varid'>z</span></a>
<span class=hs-linenum>357: </span><span class='hs-varop'>&gt;</span> <span class='hs-definition'>fold</span> <span class='hs-varid'>z</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x545:a^"lq_tmp_x108"
-&gt; lq_tmp_x546:b^"lq_tmp_x110" -&gt; b^"lq_tmp_x111"</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{VV : a^"lq_tmp_x113" | VV == x#a1bD}</span><span class='hs-varid'>x</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>forall b a.
lq_tmp_x480:b^"lq_tmp_x105"
-&gt; lq_tmp_x481:(lq_tmp_x478:a^"lq_tmp_x108"
                -&gt; lq_tmp_x479:b^"lq_tmp_x110" -&gt; b^"lq_tmp_x111")
-&gt; lq_tmp_x482:[a^"lq_tmp_x113"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x115"
-&gt; b^"lq_tmp_x116"</span><span class='hs-varid'>fold</span></a> <a class=annot href="#"><span class=annottext>{VV : b^"lq_tmp_x105" | VV == z#a1bz}</span><span class='hs-varid'>z</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x538:a^"lq_tmp_x108"
-&gt; lq_tmp_x539:b^"lq_tmp_x110" -&gt; b^"lq_tmp_x111"</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x541 : [a^"lq_tmp_x113" "lq_tmp_x114"]&lt;\lq_tmp_x540 VV -&gt; True&gt; | len lq_tmp_x541 &gt;= 0 &amp;&amp; lq_tmp_x541 == xs#a1bE}</span><span class='hs-varid'>xs</span></a><span class='hs-layout'>)</span>
</pre>
<p>Notice how <code>fold</code> essentially replaces <code>[]</code> with <code>z</code> and <code>(:)</code> with <code>f</code>, that is,</p>
<pre><code>fold f z [a,b,c] == a `f` (b `f` (c `f` z))</code></pre>
<p>(If you think about <code>fold</code> from this perspective, you may be able to figure out how to generalize <code>fold</code> to data types other than lists...)</p>
<p>Now let's rewrite <code>sum'</code>, <code>product'</code>, and <code>length'</code> in terms of <code>fold</code>:</p>
<pre><span class=hs-linenum>369: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1875:[GHC.Integer.Type.Integer^"lq_tmp_x249"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x251"
-&gt; GHC.Integer.Type.Integer^"lq_tmp_x252"</span><span class='hs-definition'>sum''</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1899:{lq_tmp_x1905 : GHC.Integer.Type.Integer^"lq_tmp_x1904" "lq_tmp_x105" | k_1903[VV#1902:=lq_tmp_x1905]}
-&gt; lq_tmp_x1900:(lq_tmp_x1897:{lq_tmp_x1909 : GHC.Integer.Type.Integer^"lq_tmp_x1908" "lq_tmp_x108" | k_1907[VV#1906:=lq_tmp_x1909]}
                 -&gt; lq_tmp_x1898:{lq_tmp_x1905 : GHC.Integer.Type.Integer^"lq_tmp_x1904" "lq_tmp_x110" | k_1903[VV#1902:=lq_tmp_x1905]}
                 -&gt; {lq_tmp_x1905 : GHC.Integer.Type.Integer^"lq_tmp_x1904" "lq_tmp_x111" | k_1903[VV#1902:=lq_tmp_x1905]})
-&gt; lq_tmp_x1901:[{lq_tmp_x1909 : GHC.Integer.Type.Integer^"lq_tmp_x1908" "lq_tmp_x113" | k_1907[VV#1906:=lq_tmp_x1909]}]&lt;\lq_tmp_x1892 VV -&gt; True&gt;^"lq_tmp_x115"
-&gt; {lq_tmp_x1905 : GHC.Integer.Type.Integer^"lq_tmp_x1904" "lq_tmp_x116" | k_1903[VV#1902:=lq_tmp_x1905]}</span><span class='hs-varid'>fold</span></a> <span class='hs-num'>0</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1916:GHC.Integer.Type.Integer^"lq_tmp_x1885"
-&gt; lq_tmp_x1917:GHC.Integer.Type.Integer^"lq_tmp_x1885"
-&gt; {lq_tmp_x1913 : GHC.Integer.Type.Integer^"lq_tmp_x1885" | lq_tmp_x1913 == lq_tmp_x1916 + lq_tmp_x1917}</span><span class='hs-layout'>(</span></a><span class='hs-varop'>+</span><span class='hs-layout'>)</span>
<span class=hs-linenum>370: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1774:[GHC.Integer.Type.Integer^"lq_tmp_x239"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x241"
-&gt; GHC.Integer.Type.Integer^"lq_tmp_x242"</span><span class='hs-definition'>product''</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1798:{lq_tmp_x1804 : GHC.Integer.Type.Integer^"lq_tmp_x1803" "lq_tmp_x105" | k_1802[VV#1801:=lq_tmp_x1804]}
-&gt; lq_tmp_x1799:(lq_tmp_x1796:{lq_tmp_x1808 : GHC.Integer.Type.Integer^"lq_tmp_x1807" "lq_tmp_x108" | k_1806[VV#1805:=lq_tmp_x1808]}
                 -&gt; lq_tmp_x1797:{lq_tmp_x1804 : GHC.Integer.Type.Integer^"lq_tmp_x1803" "lq_tmp_x110" | k_1802[VV#1801:=lq_tmp_x1804]}
                 -&gt; {lq_tmp_x1804 : GHC.Integer.Type.Integer^"lq_tmp_x1803" "lq_tmp_x111" | k_1802[VV#1801:=lq_tmp_x1804]})
-&gt; lq_tmp_x1800:[{lq_tmp_x1808 : GHC.Integer.Type.Integer^"lq_tmp_x1807" "lq_tmp_x113" | k_1806[VV#1805:=lq_tmp_x1808]}]&lt;\lq_tmp_x1791 VV -&gt; True&gt;^"lq_tmp_x115"
-&gt; {lq_tmp_x1804 : GHC.Integer.Type.Integer^"lq_tmp_x1803" "lq_tmp_x116" | k_1802[VV#1801:=lq_tmp_x1804]}</span><span class='hs-varid'>fold</span></a> <span class='hs-num'>1</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1815:GHC.Integer.Type.Integer^"lq_tmp_x1784"
-&gt; lq_tmp_x1816:GHC.Integer.Type.Integer^"lq_tmp_x1784"
-&gt; {lq_tmp_x1812 : GHC.Integer.Type.Integer^"lq_tmp_x1784" | lq_tmp_x1815 == 0 || lq_tmp_x1816 == 0 =&gt; lq_tmp_x1812 == 0 &amp;&amp; lq_tmp_x1815 &gt; 0 &amp;&amp; lq_tmp_x1816 &gt; 0 =&gt; lq_tmp_x1812 &gt;= lq_tmp_x1815 &amp;&amp; lq_tmp_x1812 &gt;= lq_tmp_x1816 &amp;&amp; lq_tmp_x1815 &gt; 1 &amp;&amp; lq_tmp_x1816 &gt; 1 =&gt; lq_tmp_x1812 &gt; lq_tmp_x1815 &amp;&amp; lq_tmp_x1812 &gt; lq_tmp_x1816}</span><span class='hs-layout'>(</span></a><span class='hs-varop'>*</span><span class='hs-layout'>)</span>
<span class=hs-linenum>371: </span><span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>forall a.
lq_tmp_x1818:[a^"lq_tmp_x244"]&lt;\fldList VV -&gt; True&gt;^"lq_tmp_x246"
-&gt; GHC.Integer.Type.Integer^"lq_tmp_x247"</span><span class='hs-definition'>length''</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x1857:{lq_tmp_x1863 : GHC.Integer.Type.Integer^"lq_tmp_x1862" "lq_tmp_x105" | k_1861[VV#1860:=lq_tmp_x1863]}
-&gt; lq_tmp_x1858:(lq_tmp_x1855:{VV#1864 : a^"lq_tmp_x1866" "lq_tmp_x108" | k_1865}
                 -&gt; lq_tmp_x1856:{lq_tmp_x1863 : GHC.Integer.Type.Integer^"lq_tmp_x1862" "lq_tmp_x110" | k_1861[VV#1860:=lq_tmp_x1863]}
                 -&gt; {lq_tmp_x1863 : GHC.Integer.Type.Integer^"lq_tmp_x1862" "lq_tmp_x111" | k_1861[VV#1860:=lq_tmp_x1863]})
-&gt; lq_tmp_x1859:[{VV#1864 : a^"lq_tmp_x1866" "lq_tmp_x113" | k_1865}]&lt;\lq_tmp_x1850 VV -&gt; True&gt;^"lq_tmp_x115"
-&gt; {lq_tmp_x1863 : GHC.Integer.Type.Integer^"lq_tmp_x1862" "lq_tmp_x116" | k_1861[VV#1860:=lq_tmp_x1863]}</span><span class='hs-varid'>fold</span></a> <span class='hs-num'>0</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>lq_tmp_x1872:{VV#1821 : a^"lq_tmp_x1823" | k_1822}
-&gt; lq_tmp_x1873:{lq_tmp_x1868 : GHC.Integer.Type.Integer^"lq_tmp_x1827" | k_1826[VV#1825:=lq_tmp_x1868][ds_d1fM:=lq_tmp_x1872]}
-&gt; {lq_tmp_x1869 : GHC.Integer.Type.Integer^"lq_tmp_x1831" | k_1830[VV#1829:=lq_tmp_x1869][ds_d1fM:=lq_tmp_x1872][s#a1bF:=lq_tmp_x1873]}</span><span class='hs-keyglyph'>\</span></a><span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>{VV#1825 : GHC.Integer.Type.Integer^"lq_tmp_x1827" | k_1826}</span><span class='hs-varid'>s</span></a> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x1845 : GHC.Integer.Type.Integer | lq_tmp_x1845 == 1 &amp;&amp; lq_tmp_x1845 == lq_anf__d1gO}</span><span class='hs-num'>1</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x1839:GHC.Integer.Type.Integer^"lq_tmp_x1841"
-&gt; lq_tmp_x1840:GHC.Integer.Type.Integer^"lq_tmp_x1841"
-&gt; {lq_tmp_x1842 : GHC.Integer.Type.Integer^"lq_tmp_x1841" | lq_tmp_x1842 == lq_tmp_x1839 + lq_tmp_x1840}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x1846 : GHC.Integer.Type.Integer^"lq_tmp_x1827" | k_1826[VV#1825:=lq_tmp_x1846] &amp;&amp; lq_tmp_x1846 == s#a1bF}</span><span class='hs-varid'>s</span></a><span class='hs-layout'>)</span>
</pre>
<p>(Instead of <code>(\_ s -&gt; 1 + s)</code> we could also write <code>(\_ -&gt; (1+))</code> or even <code>(const (1+))</code>.)</p>
<p>Of course, <code>fold</code> is already provided in the standard Prelude, under the name <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:foldr"><code>foldr</code></a>. The arguments to <code>foldr</code> are in a slightly different order but it's the exact same function. Here are some Prelude functions which are defined in terms of <code>foldr</code>:</p>
<ul>
<li><code>length</code> <code>::          [a] -&gt; Int</code></li>
<li><code>sum</code> <code>:: Num a =&gt; [a] -&gt; a</code></li>
<li><code>product</code> <code>:: Num a =&gt; [a] -&gt; a</code></li>
<li><code>and</code> <code>::          [Bool] -&gt; Bool</code></li>
<li><code>or</code> <code>::          [Bool] -&gt; Bool</code></li>
<li><code>any</code> <code>:: (a -&gt; Bool) -&gt; [a] -&gt; Bool</code></li>
<li><code>all</code> <code>:: (a -&gt; Bool) -&gt; [a] -&gt; Bool</code></li>
</ul>
<p>There is also <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:foldl"><code>foldl</code></a>, which folds &quot;from the left&quot;. That is,</p>
<pre><code>foldr f z [a,b,c] == a `f` (b `f` (c `f` z))
foldl f z [a,b,c] == ((z `f` a) `f` b) `f` c</code></pre>
<p>In general, however, you should use <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v:foldl"><code>foldl'</code> from <code>Data.List</code></a> instead, which does the same thing as <code>foldl</code> but is more efficient.</p>
<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>
